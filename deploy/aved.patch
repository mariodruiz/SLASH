diff --git a/fw/AMC/build/amc_version.json b/fw/AMC/build/amc_version.json
deleted file mode 100644
index d35941a..0000000
--- a/fw/AMC/build/amc_version.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-  "BUILD_BRANCH":"",
-  "VERSION_HASH":"37139f62ff1333680cda75c952112a85c01e131d",
-  "VERSION_HASH_DATE":"20240725",
-  "AMC_VERSION_RELEASE":"2.3.0",
-  "AMC_VERSION_MAJOR":2,
-  "AMC_VERSION_MINOR":3,
-  "AMC_VERSION_PATCH":0,
-  "AMC_DEV_COMMITS":0,
-  "AMC_DEV_STATUS":0
-}
diff --git a/fw/AMC/src/apps/in_band/in_band_telemetry.c b/fw/AMC/src/apps/in_band/in_band_telemetry.c
index e69615e..3f226d3 100644
--- a/fw/AMC/src/apps/in_band/in_band_telemetry.c
+++ b/fw/AMC/src/apps/in_band/in_band_telemetry.c
@@ -624,6 +624,7 @@ static int iAmiCallback( EVL_SIGNAL *pxSignal )
                 PLL_DBG( IN_BAND_NAME, "PDI last packet      : 0x%x\r\n",   xDownloadRequest.iLastPacket );
                 PLL_DBG( IN_BAND_NAME, "PDI packet number    : 0x%hx\r\n",  xDownloadRequest.usPacketNum );
                 PLL_DBG( IN_BAND_NAME, "PDI packet size (KB) : 0x%hx\r\n",  xDownloadRequest.usPacketSize );
+                PLL_DBG( IN_BAND_NAME, "PDI partial bitstream: 0x%hhx\r\n", xDownloadRequest.usPartial );
 
                 if( TRUE == xDownloadRequest.iUpdateFpt )
                 {
@@ -645,7 +646,9 @@ static int iAmiCallback( EVL_SIGNAL *pxSignal )
                                                   ( uint32_t )HAL_RPU_SHARED_MEMORY_BASE_ADDR,
                                                   xDownloadRequest.ulLength,
                                                   xDownloadRequest.usPacketNum,
-                                                  xDownloadRequest.usPacketSize );
+                                                  xDownloadRequest.usPacketSize,
+                                                  xDownloadRequest.iLastPacket,
+                                                  xDownloadRequest.usPartial );
                 }
 
                 if( OK != iStatus )
diff --git a/fw/AMC/src/fal/gcq/fw_if_gcq_amc.c b/fw/AMC/src/fal/gcq/fw_if_gcq_amc.c
index f324b86..8a04e8d 100644
--- a/fw/AMC/src/fal/gcq/fw_if_gcq_amc.c
+++ b/fw/AMC/src/fal/gcq/fw_if_gcq_amc.c
@@ -451,6 +451,7 @@ static uint32_t prvGCQClose( void *pvFWIf )
         */
         pxProfile->xState = FW_IF_GCQ_STATE_CLOSED;
         INC_STAT_COUNTER( FW_IF_GCQ_STATS_CLOSE_COUNT );
+        xGCQDeinit(pxProfile->pxGCQInstance);
     }
 
     return xRet;
diff --git a/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.c b/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.c
index 72b4cdd..62c77f5 100644
--- a/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.c
+++ b/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.c
@@ -175,6 +175,7 @@ typedef enum AMI_CMD_OPCODE_REQ
     AMI_CMD_OPCODE_PDI_DOWNLOAD_REQ    = 0xA,
     AMI_CMD_OPCODE_SENSOR_REQ          = 0xC,
     AMI_CMD_OPCODE_PDI_COPY_REQ        = 0xD,
+    AMI_CMD_OPCODE_PARTIAL_PDI_DOWNLOAD_REQ = 0xE,
     AMI_CMD_OPCODE_IDENTIFY_REQ        = 0x202,
 
     MAX_AMI_CMD_OPCODE
@@ -392,6 +393,7 @@ typedef struct AMI_CMD_DATA_PAYLOAD
     uint16_t usPacketNum:15;
     uint16_t usPacketSize; /* packet size in KB */
     uint32_t ulPad;
+    uint8_t usPartial;
 
 } AMI_CMD_DATA_PAYLOAD;
 
@@ -558,8 +560,8 @@ static int iHandleDebugVerbosityRequest( AMI_CMD_REQUEST *pxCmdRequest );
 int iAMI_Initialise( uint8_t ucProxyId, FW_IF_CFG *pxFwIf, uint32_t ulFwIfPort,
                      uint32_t ulTaskPrio, uint32_t ulTaskStack )
 {
-    int iStatus = ERROR;
 
+    int iStatus = ERROR;
     if( ( UPPER_FIREWALL == pxThis->ulUpperFirewall ) &&
         ( LOWER_FIREWALL == pxThis->ulLowerFirewall ) &&
         ( FALSE == pxThis->iInitialised ) &&
@@ -996,10 +998,33 @@ int iAMI_GetPdiDownloadRequest( EVL_SIGNAL *pxSignal,
                              pxThis->xRxData[ ucIndex ].xDownloadRequest.iUpdateFpt;
                 pxDownloadRequest->iLastPacket =
                              pxThis->xRxData[ ucIndex ].xDownloadRequest.iLastPacket;
+                pxDownloadRequest->usPartial = 0;
                 iStatus = OK;
             }
-            else
+            else if( AMI_CHECK_VALID_INDEX( ucIndex ) &&
+                ( TRUE == pxThis->xRxData[ ucIndex ].ucInUse ) &&
+                AMI_CMD_OPCODE_PARTIAL_PDI_DOWNLOAD_REQ == pxThis->xRxData[ ucIndex ].xOpCode )
             {
+                pxDownloadRequest->iBootDevice =
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.iBootDevice;
+                pxDownloadRequest->ullAddress =
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.ullAddress;
+                pxDownloadRequest->ulLength =
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.ulLength;
+                pxDownloadRequest->ulPartitionSel =
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.ulPartitionSel;
+                pxDownloadRequest->usPacketNum =
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.usPacketNum;
+                pxDownloadRequest->usPacketSize =
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.usPacketSize;
+                pxDownloadRequest->iUpdateFpt =
+                             pxThis->xRxData[ ucIndex ].xDownloadRequest.iUpdateFpt;
+                pxDownloadRequest->iLastPacket =
+                             pxThis->xRxData[ ucIndex ].xDownloadRequest.iLastPacket;
+                pxDownloadRequest->usPartial = 1;
+                iStatus = OK;
+            }
+            else {
                 PLL_ERR( AMI_NAME, "Error invalid PDI download request for instance\r\n" );
                 INC_ERROR_COUNTER_WITH_STATE( AMI_PROXY_ERRORS_PDI_DOWNLOAD_REQUEST )
             }
@@ -1616,6 +1641,72 @@ static void vProxyDriverTask( void *pvArgs )
                     }
                     break;
                 }
+                case AMI_CMD_OPCODE_PARTIAL_PDI_DOWNLOAD_REQ:
+                {
+                    if( OSAL_ERRORS_NONE == iOSAL_Mutex_Take( pxThis->pvOsalMutexHdl,
+                                                              OSAL_TIMEOUT_WAIT_FOREVER ) )
+                    {
+                        INC_STAT_COUNTER( AMI_PROXY_STATS_TAKE_MUTEX )
+
+                        iStatus = iFindNextFreeRxDataIndex( &ucIndex );
+                        if( ERROR != iStatus )
+                        {
+                            pxThis->xRxData[ ucIndex ].usCid = xCmdRequest.xHdr.usCid;
+                            pxThis->xRxData[ ucIndex ].xOpCode = xCmdRequest.xHdr.ulOpCode;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.iBootDevice =
+                                                                xCmdRequest.xPdiDownloadPayload.ulBootDevice;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.ullAddress =
+                                                                xCmdRequest.xPdiDownloadPayload.ullAddress;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.ulLength =
+                                                                xCmdRequest.xPdiDownloadPayload.ulSize;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.ulPartitionSel =
+                                                                xCmdRequest.xPdiDownloadPayload.ulPartitionSel;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.usPacketNum =
+                                                                xCmdRequest.xPdiDownloadPayload.usPacketNum;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.usPacketSize =
+                                                                xCmdRequest.xPdiDownloadPayload.usPacketSize;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.iUpdateFpt =
+                                                                xCmdRequest.xPdiDownloadPayload.ulUpdateFpt;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.iLastPacket =
+                                                                xCmdRequest.xPdiDownloadPayload.usLastPacket;
+                            pxThis->xRxData[ ucIndex ].ucInUse = TRUE;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.usPartial = 1;
+                        }
+                        else
+                        {
+                            INC_ERROR_COUNTER_WITH_STATE( AMI_PROXY_RX_DATA_INDEX_FAILED )
+                        }
+
+                        if( OSAL_ERRORS_NONE != iOSAL_Mutex_Release( pxThis->pvOsalMutexHdl ) )
+                        {
+                            INC_ERROR_COUNTER_WITH_STATE( AMI_PROXY_ERRORS_MUTEX_RELEASE_FAILED )
+                        }
+
+                        if( ERROR != iStatus )
+                        {
+                            INC_STAT_COUNTER( AMI_PROXY_STATS_RELEASE_MUTEX )
+
+                            /* Raise event using the index as the method to track the event */
+                            EVL_SIGNAL xNewSignal = { pxThis->ucMyId,
+                                                    AMI_PROXY_DRIVER_E_PDI_DOWNLOAD_START,
+                                                    ucIndex,
+                                                    0 };
+                            iStatus = iEVL_RaiseEvent( pxThis->pxEvlRecord, &xNewSignal );
+                            if( ERROR == iStatus )
+                            {
+                                PLL_ERR( AMI_NAME, "Error attempting to raise event 0x%x\r\n",
+                                         AMI_PROXY_DRIVER_E_PDI_DOWNLOAD_START );
+                                INC_ERROR_COUNTER_WITH_STATE( AMI_PROXY_RAISE_EVENT_PDI_DOWNLOAD_FAILED )
+                            }
+                        }
+                    }
+                    else
+                    {
+                        INC_ERROR_COUNTER_WITH_STATE( AMI_PROXY_ERRORS_MUTEX_TAKE_FAILED )
+                    }
+                    break;
+                }
+
                 case AMI_CMD_OPCODE_PDI_COPY_REQ:
                 {
                     if( OSAL_ERRORS_NONE == iOSAL_Mutex_Take( pxThis->pvOsalMutexHdl,
diff --git a/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.h b/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.h
index a77dc6c..126dd85 100644
--- a/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.h
+++ b/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.h
@@ -47,6 +47,7 @@ typedef enum AMI_PROXY_DRIVER_EVENTS
     AMI_PROXY_DRIVER_E_EEPROM_READ_WRITE,
     AMI_PROXY_DRIVER_E_MODULE_READ_WRITE,
     AMI_PROXY_DRIVER_E_DEBUG_VERBOSITY,
+    AMI_PROXY_DRIVER_E_PDI_PARTIAL_DOWNLOAD_START,
 
     MAX_AMI_PROXY_DRIVER_EVENTS
 
@@ -152,6 +153,7 @@ typedef struct AMI_PROXY_PDI_DOWNLOAD_REQUEST
     uint32_t ulPartitionSel;
     uint16_t usPacketNum; 
     uint16_t usPacketSize;
+    uint8_t usPartial;
 
 } AMI_PROXY_PDI_DOWNLOAD_REQUEST;
 
diff --git a/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.c b/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.c
index 58b16b7..ce0cfcb 100644
--- a/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.c
+++ b/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.c
@@ -18,6 +18,7 @@
 #include "osal.h"
 #include "apc_proxy_driver.h"
 #include "profile_hal.h"
+#include "profile_fal.h"
 
 /******************************************************************************/
 /* Defines                                                                    */
@@ -53,6 +54,22 @@
 #define APC_FPT_HDR_MAGIC_NUM ( 0x92F7A516 )
 #endif
 
+#define PDI_PARTIAL_ADDR 0x100000
+#define PDI_PARTIAL_ADDR_HIGH 0x00
+#define TIMEOUT_PDI_TRIGGER (4 * 1000)
+
+/* PDI Reload commands */
+#define PDI_RELOAD_CMD_ADDR 0xFF3F0A40
+#define PDI_RELOAD_CMD_DDR (PDI_RELOAD_CMD_ADDR + 4)
+#define PDI_RELOAD_ADDR_HIGH (PDI_RELOAD_CMD_ADDR + 8)
+#define PDI_RELOAD_ADDR_LOW (PDI_RELOAD_CMD_ADDR + 12)
+#define PDI_RELOAD_CMD_TRIGGER (0xFF360000)
+#define PDI_RELOAD_POLL_DONE (0xFF360004)
+
+/* PDI Reload values */
+#define PDI_LOAD 0x30701
+#define PDI_LOAD_DDR 0x0F
+#define IPI_RPU 0x02
 /* Stat & Error definitions */
 #define APC_PROXY_STATS( DO )                            \
 	DO( APC_PROXY_STATS_INIT_OVERALL_COMPLETE )      \
@@ -164,6 +181,7 @@ typedef enum
 	APC_MSG_TYPE_COPY_PDI,
 	APC_MSG_TYPE_PARTITION_SELECT,
 	APC_MSG_TYPE_ENABLE_HOT_RESET,
+	APC_MSG_TYPE_DOWNLOAD_PARTIAL_PDI,
 	MAX_APC_MSG_TYPE
 
 } APC_MSG_TYPES;
@@ -205,9 +223,8 @@ typedef struct APC_PRIVATE_DATA
 
 	uint32_t pulStats[ APC_PROXY_STATS_MAX ];
 	uint32_t pulErrors[ APC_PROXY_ERRORS_MAX ];
-
+	void* pvTimerHandle;
 	uint32_t ulLowerFirewall;
-
 } APC_PRIVATE_DATA;
 
 /**
@@ -353,6 +370,15 @@ static int iVerifyDownload( APC_MBOX_DOWNLOAD_IMAGE *pxImageData );
  */
 static int iRefreshFptData( APC_BOOT_DEVICES xBootDevice );
 
+/**
+ * @brief   Run partial bitstream
+ *
+ * @param   pxImageData Pointer to data regarding the image to download
+ *
+ * @return  OK if the image was successfully downloaded
+ *          ERROR if the image was not successfully downloaded
+ */
+static int iProgramPartial (APC_MBOX_DOWNLOAD_IMAGE *pxImageData);
 
 /******************************************************************************/
 /* Local variables                                                            */
@@ -391,10 +417,13 @@ static APC_PRIVATE_DATA xLocalData =
 	{
 		0
 	},                                                                     /* puErrors */
+	NULL,                                                                  /* pvTimerHandle */
 	LOWER_FIREWALL                                                         /* ulLowerFirewall */
 };
 static APC_PRIVATE_DATA *pxThis = &xLocalData;
 
+static void vTimerTriggerCb ( void *pvTimerHandle );
+
 
 /******************************************************************************/
 /* Public Function implementations                                            */
@@ -428,6 +457,14 @@ int iAPC_Initialise( uint8_t ucProxyId,
 		/* used for primary boot device only */
 		pxThis->ulNextBootAddr = APC_MULTIBOOT_REAL( HAL_IO_READ32( HAL_APC_PMC_BOOT_REG ) );
 
+		/* initialise timer */
+		if (OSAL_ERRORS_NONE != iOSAL_Timer_Create( &pxThis->pvTimerHandle,
+													OSAL_TIMER_CONFIG_ONE_SHOT,
+													vTimerTriggerCb,
+													"pl_reload_timer"))
+		{
+			PLL_ERR( APC_NAME, "Error: iOSAL_Timer_Create failed\r\n");
+		}
 		/* initalise evl record*/
 		if( OK != iEVL_CreateRecord( &pxThis->pxEvlRecord ) )
 		{
@@ -598,7 +635,9 @@ int iAPC_DownloadImage( EVL_SIGNAL *pxSignal,
                         uint32_t ulSrcAddr,
                         uint32_t ulImageSize,
                         uint16_t usPacketNum,
-                        uint16_t usPacketSize )
+                        uint16_t usPacketSize,
+						int iLastPacket,
+						uint8_t  usPartial )
 {
 	int iStatus = ERROR;
 
@@ -616,7 +655,9 @@ int iAPC_DownloadImage( EVL_SIGNAL *pxSignal,
 			{
 				0
 			};
-			xMsg.eMsgType                        = APC_MSG_TYPE_DOWNLOAD_PDI;
+			xMsg.eMsgType                        = (usPartial) ?
+			APC_MSG_TYPE_DOWNLOAD_PARTIAL_PDI :
+			APC_MSG_TYPE_DOWNLOAD_PDI;
 			xMsg.ucRequestId                     = pxSignal->ucInstance;
 			xMsg.xDownloadImageData.xBootDevice  = xBootDevice;
 			xMsg.xDownloadImageData.iPartition   = iPartition;
@@ -625,6 +666,7 @@ int iAPC_DownloadImage( EVL_SIGNAL *pxSignal,
 			xMsg.xDownloadImageData.ulSrcAddr    = ulSrcAddr;
 			xMsg.xDownloadImageData.usPacketNum  = usPacketNum;
 			xMsg.xDownloadImageData.usPacketSize = usPacketSize;
+			xMsg.xDownloadImageData.iLastPacket  = iLastPacket;
 
 			if( OSAL_ERRORS_NONE == iOSAL_MBox_Post( pxThis->pvOsalMBoxHdl,
 			                                         ( void* )&xMsg,
@@ -1222,6 +1264,24 @@ static void vProxyDriverTask( void *pArg )
 			}
 			break;
 
+			case APC_MSG_TYPE_DOWNLOAD_PARTIAL_PDI:
+			{
+				xSignal.ucEventType = APC_PROXY_DRIVER_E_DOWNLOAD_STARTED;
+				if( OK == iProgramPartial( &xMBoxData.xDownloadImageData)) {
+					INC_STAT_COUNTER( APC_PROXY_STATS_IMAGE_DOWNLOAD_COMPLETE )
+					xSignal.ucEventType = APC_PROXY_DRIVER_E_DOWNLOAD_COMPLETE;
+				}
+				else
+				{
+					INC_ERROR_COUNTER_WITH_STATE( APC_PROXY_ERRORS_IMAGE_DOWNLOAD_FAILED )
+					xSignal.ucEventType = APC_PROXY_DRIVER_E_DOWNLOAD_FAILED;
+				}
+				if( OK != iEVL_RaiseEvent( pxThis->pxEvlRecord, &xSignal ) )
+				{
+					INC_ERROR_COUNTER_WITH_STATE( APC_PROXY_ERRORS_RAISE_EVENT_FAILED )
+				}
+			}
+			break;
 			default:
 			{
 				INC_ERROR_COUNTER_WITH_STATE( APC_PROXY_ERRORS_MBOX_PEND_FAILED )
@@ -1875,3 +1935,73 @@ static int iVerifyDownload( APC_MBOX_DOWNLOAD_IMAGE *pxImageData )
 
 	return iStatus;
 }
+
+/**
+ * @brief   Program FPGA with partial image
+ */
+uint8_t* rsvd_mem_partial_program = ( uint8_t* ) PDI_PARTIAL_ADDR; // base address for PDI download
+static int iProgramPartial (APC_MBOX_DOWNLOAD_IMAGE *pxImageData)
+{
+	uint32_t ulAddr = pxImageData->ulSrcAddr;
+	uint32_t ulImageSize = pxImageData->ulImageSize;
+	uint8_t usLast = pxImageData->iLastPacket;
+	uint16_t packetSize = pxImageData->usPacketSize;
+	uint16_t packetNum = pxImageData->usPacketNum;
+	uint8_t *pucPdiData = (uint8_t *)(uintptr_t)(pxImageData->ulSrcAddr);
+	HAL_FLUSH_CACHE_DATA( ( uintptr_t )( pxImageData->ulSrcAddr ), ulImageSize );
+	PLL_DBG(APC_NAME, "Source addr: 0x%x\n\r", ulAddr);
+	PLL_DBG(APC_NAME, "Image size: 0x%x\n\r", ulImageSize);
+	PLL_DBG(APC_NAME, "Last packet: %u\n\r", usLast);
+	PLL_DBG(APC_NAME, "Packet size: %u\n\r", packetSize);
+	PLL_DBG(APC_NAME, "Packet number: %u\n\r", packetNum);
+	uint32_t destAddr = pxImageData->usPacketNum * ( pxImageData->usPacketSize * APC_BASE_PACKET_SIZE );
+	PLL_DBG(APC_NAME, "Dest addr: 0x%x\n\r", destAddr);
+	if( NULL == pvOSAL_MemCpy(rsvd_mem_partial_program + destAddr, pucPdiData, ulImageSize) )
+	{
+		PLL_ERR(APC_NAME, "Error: MemCpy");
+		return ERROR;
+	}
+
+	if( usLast == 1 )
+	{
+		if( OSAL_ERRORS_NONE != iOSAL_Timer_Start( pxThis->pvTimerHandle, TIMEOUT_PDI_TRIGGER ) )
+		{
+			PLL_ERR(APC_NAME, "Error: Timer start");
+		}
+	}
+
+	return OK;
+}
+
+int iTriggerPartial ()
+{
+	if( OSAL_ERRORS_NONE != iOSAL_Mutex_Take( pxThis->pvOsalMutexHdl, OSAL_TIMEOUT_WAIT_FOREVER ) )
+	{
+		INC_ERROR_COUNTER_WITH_STATE( APC_PROXY_ERRORS_MUTEX_TAKE_FAILED )
+	}
+
+	xGcqIf.close(&xGcqIf);
+	HAL_IO_WRITE32(PDI_LOAD, PDI_RELOAD_CMD_ADDR);
+	HAL_IO_WRITE32(PDI_LOAD_DDR, PDI_RELOAD_CMD_DDR);
+	HAL_IO_WRITE32(PDI_PARTIAL_ADDR_HIGH, PDI_RELOAD_ADDR_HIGH);
+	HAL_IO_WRITE32(PDI_PARTIAL_ADDR, PDI_RELOAD_ADDR_LOW);
+	PLL_LOG(APC_NAME, "Triggering IPI...\r\n");
+	iOSAL_Task_SleepMs( APC_TASK_SLEEP_MS );
+	HAL_IO_WRITE32(IPI_RPU, PDI_RELOAD_CMD_TRIGGER);
+	while (HAL_IO_READ32(PDI_RELOAD_POLL_DONE) != 0) {}
+	PLL_LOG(APC_NAME, "PDI done...\r\n");
+	xGcqIf.open(&xGcqIf);
+	if( OSAL_ERRORS_NONE != iOSAL_Mutex_Release( pxThis->pvOsalMutexHdl ) )
+	{
+		INC_ERROR_COUNTER_WITH_STATE( APC_PROXY_ERRORS_MUTEX_RELEASE_FAILED )
+	}
+
+	return OK;
+}
+
+static void vTimerTriggerCb ( void *pvTimerHandle )
+{
+	iTriggerPartial();
+	iOSAL_Timer_Stop(pvTimerHandle);
+
+}
\ No newline at end of file
diff --git a/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.h b/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.h
index 757ba56..da92d67 100644
--- a/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.h
+++ b/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.h
@@ -41,6 +41,9 @@ typedef enum APC_PROXY_DRIVER_EVENTS
     APC_PROXY_DRIVER_E_COPY_FAILED,
     APC_PROXY_DRIVER_E_PARTITION_SELECTED,
     APC_PROXY_DRIVER_E_PARTITION_SELECTION_FAILED,
+    APC_PROXY_DRIVER_E_PARTIAL_DOWNLOAD_STARTED,
+    APC_PROXY_DRIVER_E_PARTIAL_DOWNLOAD_COMPLETE,
+    APC_PROXY_DRIVER_E_PARTIAL_DOWNLOAD_FAILED,
 
     MAX_APC_PROXY_DRIVER_EVENTS
 
@@ -136,13 +139,14 @@ int iAPC_BindCallback( EVL_CALLBACK *pxCallback );
  * @param   ulImageSize  Size of image (in bytes)
  * @param   usPacketNum  Image packet number
  * @param   usPacketSize Size of image packet (in KB)
+ * @param   usPartial    Flag that indicates if this is a partial PDI
  *
  * @return  OK           Image downloaded successfully
  *          ERROR        Image not downloaded successfully
  * 
  */
 int iAPC_DownloadImage( EVL_SIGNAL *pxSignal, APC_BOOT_DEVICES xBootDevice, int iPartition, uint32_t ulSrcAddr,
-                        uint32_t ulImageSize, uint16_t usPacketNum, uint16_t usPacketSize );
+                        uint32_t ulImageSize, uint16_t usPacketNum, uint16_t usPacketSize, int usLastPacket, uint8_t usPartial );
 
 /**
  * @brief   Download an image with an FPT to a location in NV memory
@@ -254,4 +258,12 @@ int iAPC_ClearStatistics( void );
  */
 int iAPC_GetState( MODULE_STATE *pxState );
 
+/**
+ * @brief   Trigger partial programming
+ *
+ * @return  OK              If successful
+ *          ERROR           If not successful
+ */
+int iTriggerPartial ();
+
 #endif
diff --git a/fw/AMC/src/proxy_drivers/apc/debug/apc_proxy_driver_debug.c b/fw/AMC/src/proxy_drivers/apc/debug/apc_proxy_driver_debug.c
index 63efd51..bc26318 100644
--- a/fw/AMC/src/proxy_drivers/apc/debug/apc_proxy_driver_debug.c
+++ b/fw/AMC/src/proxy_drivers/apc/debug/apc_proxy_driver_debug.c
@@ -104,6 +104,13 @@ static void vGetFptHeader( void );
  */
  static void vGetFptPartition( void );
 
+/**
+ * @brief   Debug function to trigger a partial PDI reload
+ *
+ * @return  N/A
+ */
+ static void vTriggerPartial( void );
+
 /***** Helper functions *****/
 
 /**
@@ -152,6 +159,7 @@ void vAPC_DebugInit( DAL_HDL pxParentHandle )
                 pxDAL_NewDebugFunction( "set_copy_image",     pxSetDir, vSetCopyImage );
                 pxDAL_NewDebugFunction( "set_next_partition", pxSetDir, vSetNextPartition );
                 pxDAL_NewDebugFunction( "enable_hot_reset",   pxSetDir, vSetEnableHotReset );
+                pxDAL_NewDebugFunction( "trigger_partial",    pxSetDir, vTriggerPartial );
             }
             if( NULL != pxGetDir )
             {
@@ -213,6 +221,7 @@ static void vSetDownloadImage( void )
     uint32_t ulSrcAddr = 0;
     int iPacketNum     = 0; 
     int iPacketSize    = 0;
+    int iPartial       = 0;
     
     if( OK != iDAL_GetIntInRange( "Enter request instance:", &iInstance, 0, UTIL_MAX_UINT8 ) )
     {
@@ -242,21 +251,30 @@ static void vSetDownloadImage( void )
     {
         PLL_DAL( APC_DBG_NAME, "Error retrieving packet size\r\n" );
     }
-
     else
     {
         EVL_SIGNAL xSignal = { 0 };
         xSignal.ucInstance = iInstance;
-
+        if( iPartial == 1 )
+        {
+            iTriggerPartial();
+        }
         if( OK != iAPC_DownloadImage( &xSignal, ( APC_BOOT_DEVICES )xBootDevice, iPartition, ulSrcAddr, ( uint32_t )iImageSize, 
-                                      ( uint16_t )iPacketNum, ( uint16_t )iPacketSize ) )
+                                      ( uint16_t )iPacketNum, ( uint16_t )iPacketSize, 0, ( uint8_t )iPartial ) )
         {
             PLL_DAL( APC_DBG_NAME, "Error writing %d bytes to partition %d\r\n", iImageSize, iPartition );
         }
         else
         {
-            PLL_DAL( APC_DBG_NAME, "%d bytes written from 0x%08X to partition %d\r\n",
+            if( iPartial == 0 )
+            {
+                PLL_DAL( APC_DBG_NAME, "%d bytes written from 0x%08X to partition %d\r\n",
                      iImageSize, ulSrcAddr, iPartition );
+            }
+            else
+            {
+                PLL_DAL( APC_DBG_NAME, "Partial PDI starting\r\n");
+            }
         }
     }
 }
@@ -465,3 +483,13 @@ static int iTestCallback( EVL_SIGNAL *pxSignal )
     return iStatus;
 }
 
+/**
+ * @brief   Trigger a partial PDI reload
+ */
+static void vTriggerPartial( void ) {
+    if (OK == iTriggerPartial()) {
+        PLL_DAL( APC_DBG_NAME, "Partial PDI triggered\r\n");
+    } else {
+        PLL_DAL( APC_DBG_NAME, "Error triggering partial PDI\r\n");
+    }
+}
diff --git a/hw/amd_v80_gen5x8_24.1/src/build_design.tcl b/hw/amd_v80_gen5x8_24.1/src/build_design.tcl
index 1e19be3..e829f18 100644
--- a/hw/amd_v80_gen5x8_24.1/src/build_design.tcl
+++ b/hw/amd_v80_gen5x8_24.1/src/build_design.tcl
@@ -49,6 +49,7 @@ proc do_aved_build {} {
   if {[get_property PROGRESS [get_runs impl_1]] != "100%"} {
     common::send_msg_id {BUILD_HW-6} {ERROR} "Implementation failed"
   }
+  source "$src_dir/run_post.tcl"
 
   common::send_msg_id {BUILD_HW-8} {INFO} {Done!}
 }
diff --git a/hw/amd_v80_gen5x8_24.1/src/create_design.tcl b/hw/amd_v80_gen5x8_24.1/src/create_design.tcl
index 4ddb58e..e799514 100644
--- a/hw/amd_v80_gen5x8_24.1/src/create_design.tcl
+++ b/hw/amd_v80_gen5x8_24.1/src/create_design.tcl
@@ -44,6 +44,9 @@ proc do_aved_create_design { } {
   source "$src_dir/bd/create_bd_design.tcl"
   create_root_design ""
 
+  # Add custom logic to AVED block design
+  source "$src_dir/run_pre.tcl"
+  run_pre ""
   # Write the block diagram wrapper and set it as design top
   add_files -norecurse [make_wrapper -files [get_files "${bd_name}.bd"] -top]
   update_compile_order -fileset sources_1
diff --git a/sw/AMI/api/include/ami_program.h b/sw/AMI/api/include/ami_program.h
index 4195249..3c2a7bb 100644
--- a/sw/AMI/api/include/ami_program.h
+++ b/sw/AMI/api/include/ami_program.h
@@ -104,6 +104,7 @@ struct ami_pdi_progress {
  * @boot_device: Target boot device.
  * @partition: Partition number to flash to.
  * @progress_handler: An event handler to accept progress notifications.
+ * @partial: Specify whether the PDI is partial or full.
  *
  * If a progress handler is given, a thread will be started to monitor driver
  * events - `ctr` will be equal to the number of bytes successfully written
@@ -112,7 +113,7 @@ struct ami_pdi_progress {
  * Return: AMI_STATUS_OK or AMI_STATUS_ERROR.
  */
 int ami_prog_download_pdi(ami_device *dev, const char *path, uint8_t boot_device,
-	uint32_t partition, ami_event_handler progress_handler);
+	uint32_t partition, ami_event_handler progress_handler, bool partial);
 
 /**
  * ami_prog_update_fpt() - Program a PDI containing an FPT onto a device.
diff --git a/sw/AMI/api/src/ami_ioctl.h b/sw/AMI/api/src/ami_ioctl.h
index 96efb72..61e39ca 100644
--- a/sw/AMI/api/src/ami_ioctl.h
+++ b/sw/AMI/api/src/ami_ioctl.h
@@ -41,6 +41,7 @@
  * @cap_override: Bypass permission checks. This may not apply to all IOCTL's.
  * @efd: File descriptor for event notifications (used for progress reporting when
  *     performing long running operations like PDI downloads) - optional
+ * @partial: Flag to indicate partial or full PDI
  *
  * Note that addr can be an address to any arbitrary data type,
  * depending on the context. This struct is reused for the boot select
@@ -61,6 +62,7 @@ struct ami_ioc_data_payload {
 	uint32_t       dest_part;
 	bool           cap_override;
 	int            efd;
+	bool           partial;
 };
 
 /**
diff --git a/sw/AMI/api/src/ami_program.c b/sw/AMI/api/src/ami_program.c
index c5b635e..170b638 100644
--- a/sw/AMI/api/src/ami_program.c
+++ b/sw/AMI/api/src/ami_program.c
@@ -108,11 +108,12 @@ static int read_file(const char *fname, uint8_t **buf, uint32_t *size)
  * @boot_device: Target boot device.
  * @partition: Partition number to program.
  * @progress_handler: Progress handler callback (optional).
+ * @partial: Specify whether the PDI is partial or full.
  *
  * Return: AMI_STATUS_OK or AMI_STATUS_ERROR
  */
 static int do_image_download(ami_device *dev, const char *path, uint8_t boot_device, uint32_t partition,
-	ami_event_handler progress_handler)
+	ami_event_handler progress_handler, bool partial)
 {
 	uint8_t *img_data = NULL;
 	uint32_t img_size = 0;
@@ -136,9 +137,10 @@ static int do_image_download(ami_device *dev, const char *path, uint8_t boot_dev
 		payload.boot_device = boot_device;
 		payload.partition = partition;
 		payload.efd = AMI_INVALID_FD;
+		payload.partial = partial;
 
 		if (progress_handler) {
-			progress.bytes_to_write = img_size;
+			progress.bytes_to_write = 2 * img_size;
 
 			if (ami_watch_driver_events(&evt_data, progress_handler, (void*)&progress) == AMI_STATUS_OK)
 				payload.efd = evt_data.efd;
@@ -172,7 +174,7 @@ static int do_image_download(ami_device *dev, const char *path, uint8_t boot_dev
  * Program a pdi bitstream onto a device.
  */
 int ami_prog_download_pdi(ami_device *dev, const char *path, uint8_t boot_device,
-	uint32_t partition, ami_event_handler progress_handler)
+	uint32_t partition, ami_event_handler progress_handler, bool partial)
 {
 	if (!dev || !path || (partition == AMI_IOC_FPT_UPDATE_MAGIC))
 		return AMI_API_ERROR(AMI_ERROR_EINVAL);
@@ -182,7 +184,8 @@ int ami_prog_download_pdi(ami_device *dev, const char *path, uint8_t boot_device
 		path,
 		boot_device,
 		partition,
-		progress_handler
+		progress_handler,
+		partial
 	);
 }
 
@@ -200,7 +203,8 @@ int ami_prog_update_fpt(ami_device *dev, const char *path, uint8_t boot_device,
 		path,
 		boot_device,
 		AMI_IOC_FPT_UPDATE_MAGIC,
-		progress_handler
+		progress_handler,
+		false
 	);
 }
 
@@ -211,7 +215,6 @@ int ami_prog_device_boot(struct ami_device **dev, uint32_t partition)
 {
 	int ret = AMI_STATUS_ERROR;
 	struct ami_ioc_data_payload payload = { 0 };
-
 	if (!dev || !(*dev))
 		return AMI_API_ERROR(AMI_ERROR_EINVAL);
 	
@@ -219,7 +222,7 @@ int ami_prog_device_boot(struct ami_device **dev, uint32_t partition)
 		return AMI_STATUS_ERROR; /* last error is set by ami_open_cdev */
 	
 	payload.partition = partition;
-	
+	payload.cap_override = (*dev)->cap_override;
 	if (ioctl((*dev)->cdev, AMI_IOC_DEVICE_BOOT, &payload) == AMI_LINUX_STATUS_ERROR) {
 		ret = AMI_API_ERROR_M(
 			AMI_ERROR_EIO,
@@ -230,6 +233,7 @@ int ami_prog_device_boot(struct ami_device **dev, uint32_t partition)
 	} else {
 		/* Perform hot reset. This will update the device handle. */
 		ret = ami_dev_hot_reset(dev);
+		ret = AMI_STATUS_OK;
 	}
 
 	return ret;
diff --git a/sw/AMI/app/Makefile b/sw/AMI/app/Makefile
index 91f7598..576fed1 100644
--- a/sw/AMI/app/Makefile
+++ b/sw/AMI/app/Makefile
@@ -20,7 +20,7 @@ INC_FLAGS := $(addprefix -I,$(INC_DIRS))
 AMI_LIB_DIR := ../api/build
 AMI_LIB := ami
 
-CFLAGS := $(INC_FLAGS) -Wall -Werror
+CFLAGS := $(INC_FLAGS) -Wall
 LDFLAGS := -L$(AMI_LIB_DIR) -l$(AMI_LIB) -lm -lpthread
 
 #
diff --git a/sw/AMI/app/cmd_handlers/cmd_cfgmem_program.c b/sw/AMI/app/cmd_handlers/cmd_cfgmem_program.c
index d1f0e38..f25fa76 100644
--- a/sw/AMI/app/cmd_handlers/cmd_cfgmem_program.c
+++ b/sw/AMI/app/cmd_handlers/cmd_cfgmem_program.c
@@ -235,7 +235,8 @@ static int do_cmd_cfgmem_program(struct app_option *options, int num_args, char
 					  image->arg,
 					  selected_boot_device,
 					  partition_number,
-					  progress_handler) == AMI_STATUS_OK) {
+					  progress_handler,
+					  false) == AMI_STATUS_OK) {
 			printf("\r\nImage programming complete.\r\n");
 
 			if ((NULL == find_app_option('q', options)) &&
@@ -274,7 +275,7 @@ static int do_cmd_cfgmem_program(struct app_option *options, int num_args, char
 		ret = EXIT_SUCCESS;
 		printf("\r\nAborting...\r\n");
 	}
-
+	
 	ami_dev_delete(&dev);
 	return ret;
 }
diff --git a/sw/AMI/app/cmd_handlers/cmd_device_boot.c b/sw/AMI/app/cmd_handlers/cmd_device_boot.c
index 4202ebb..957b771 100644
--- a/sw/AMI/app/cmd_handlers/cmd_device_boot.c
+++ b/sw/AMI/app/cmd_handlers/cmd_device_boot.c
@@ -122,6 +122,12 @@ static int do_cmd_device_boot(struct app_option *options, int num_args, char **a
 
 	partition_number = (uint32_t)strtoul(partition->arg, NULL, 0);
 
+
+	if(ami_dev_request_access(dev) != AMI_STATUS_OK) {
+		APP_API_ERROR("could not request access to device");
+	}
+
+
 	printf("Will do a hot reset to boot into partition %d. This may take a minute...\r\n",
 		partition_number);
 	
diff --git a/sw/AMI/driver/amc_proxy.c b/sw/AMI/driver/amc_proxy.c
index c68e87e..9e031d0 100644
--- a/sw/AMI/driver/amc_proxy.c
+++ b/sw/AMI/driver/amc_proxy.c
@@ -57,6 +57,7 @@ enum amc_proxy_cmd_opcode {
 	AMC_PROXY_CMD_OPCODE_PDI_DOWNLOAD      = 0xA,
 	AMC_PROXY_CMD_OPCODE_SENSOR            = 0xC,
         AMC_PROXY_CMD_OPCODE_PARTITION_COPY    = 0xD,
+        AMC_PROXY_CMD_OPCODE_PARTIAL_PDI_DOWNLOAD = 0xE,
 	AMC_PROXY_CMD_OPCODE_IDENTIFY          = 0x202,
 
 	/* Other commands to be added here */
@@ -983,7 +984,6 @@ int amc_proxy_request_identity(struct amc_proxy_cmd_struct *cmd)
 
         amc_ctxt = amc_proxy_find_matching_proxy_instance(cmd->cmd_fw_if_gcq);
         if (amc_ctxt && amc_ctxt->inst.initialised) {
-
                 struct amc_proxy_cmd_request request_cmd_entry = {{{{0}}}};
                 struct amc_proxy_cmd_request_hdr *request_hdr = NULL;
                 request_hdr = &(request_cmd_entry.hdr);
@@ -1076,7 +1076,9 @@ int amc_proxy_request_pdi_download(struct amc_proxy_cmd_struct *cmd,
                 struct amc_proxy_cmd_request_hdr *request_hdr = NULL;
                 request_hdr = &(request_cmd_entry.hdr);
                 request_hdr->state = AMC_PROXY_REQUEST_CMD_NEW;
-                request_hdr->opcode = AMC_PROXY_CMD_OPCODE_PDI_DOWNLOAD;
+                request_hdr->opcode = (pdi_download->partial) ?
+                AMC_PROXY_CMD_OPCODE_PARTIAL_PDI_DOWNLOAD :
+                AMC_PROXY_CMD_OPCODE_PDI_DOWNLOAD;
                 request_hdr->count = sizeof(request_cmd_entry.pdi_payload);
                 request_hdr->cid = cmd->cmd_cid;
 
@@ -1213,7 +1215,6 @@ int amc_proxy_request_heartbeat(struct amc_proxy_cmd_struct *cmd,
 
         amc_ctxt = amc_proxy_find_matching_proxy_instance(cmd->cmd_fw_if_gcq);
         if (amc_ctxt && amc_ctxt->inst.initialised) {
-
                 struct amc_proxy_cmd_request request_cmd_entry = {{{{0}}}};
                 struct amc_proxy_cmd_request_hdr *request_hdr = NULL;
                 request_hdr = &(request_cmd_entry.hdr);
diff --git a/sw/AMI/driver/amc_proxy.h b/sw/AMI/driver/amc_proxy.h
index 63673a3..09707f9 100644
--- a/sw/AMI/driver/amc_proxy.h
+++ b/sw/AMI/driver/amc_proxy.h
@@ -156,6 +156,7 @@ struct amc_proxy_pdi_download_request {
         uint16_t last_chunk;
         uint16_t chunk;
         uint16_t chunk_size;
+        bool partial;
 };
 
 /**
diff --git a/sw/AMI/driver/ami_amc_control.c b/sw/AMI/driver/ami_amc_control.c
index 6bf6b51..e3eb693 100644
--- a/sw/AMI/driver/ami_amc_control.c
+++ b/sw/AMI/driver/ami_amc_control.c
@@ -795,6 +795,9 @@ static enum amc_cmd_id get_cmd_command_id(enum gcq_submit_cmd_req cmd_req)
 		id = AMC_CMD_ID_DEBUG_VERBOSITY;
 		break;
 
+	case GCQ_SUBMIT_CMD_DOWNLOAD_PARTIAL_PDI:
+		id = AMC_CMD_ID_DOWNLOAD_PARTIAL_PDI;
+		break;
 	default:
 		id = AMC_CMD_ID_UNKNOWN;
 		break;
@@ -1222,6 +1225,7 @@ int submit_gcq_command(struct amc_control_ctxt	*amc_ctrl_ctxt,
 	switch (cmd_id) {
 	/* data_buf required */
 	case AMC_CMD_ID_DOWNLOAD_PDI:
+	case AMC_CMD_ID_DOWNLOAD_PARTIAL_PDI:
 	case AMC_CMD_ID_IDENTIFY:
 	case AMC_CMD_ID_SENSOR:
 	case AMC_CMD_ID_HEARTBEAT:
@@ -1332,6 +1336,34 @@ int submit_gcq_command(struct amc_control_ctxt	*amc_ctrl_ctxt,
 	}
 	break;
 
+	case AMC_CMD_ID_DOWNLOAD_PARTIAL_PDI:
+	/* Same as AMC_CMD_ID_DOWNLOAD_PDI. Handler changes so the change is seen in AMC */
+	{
+		if (acquire_gcq_data(amc_ctrl_ctxt, (uint32_t *)&(payload_address), &length)) {
+			ret = -EIO;
+			goto done;
+		}
+
+		data_page_acquired = true;
+		payload_size = data_size;
+
+		AMI_VDBG(amc_ctrl_ctxt,
+			 "Payload size = %d, page length = %d",
+			 payload_size,
+			 length);
+		if (length < payload_size) {
+			AMI_WARN(amc_ctrl_ctxt,
+				 "Data request length is %d but allocated length is %d",
+				 payload_size,
+				 length);
+			payload_size = length;
+		}
+
+		/* Copy payload data to address */
+		memcpy_gcq_payload_to_device(amc_ctrl_ctxt, payload_address, data_buf, data_size);
+	}
+	break;
+
 	case AMC_CMD_ID_SENSOR:
 	{
 		if (acquire_gcq_log_page_sema(amc_ctrl_ctxt,
@@ -1475,6 +1507,31 @@ int submit_gcq_command(struct amc_control_ctxt	*amc_ctrl_ctxt,
 		pdi_download_request.length = payload_size;
 		pdi_download_request.address = payload_address;
 		pdi_download_request.boot_device = PDI_BOOT_DEVICE(flags);
+		pdi_download_request.partial = false;
+
+		/* Using the `flags` argument to select the partition. */
+		if (PDI_PARTITION(flags) != FPT_UPDATE_FLAG)
+			pdi_download_request.partition = PDI_PARTITION(flags);
+		else
+			pdi_download_request.partition = FPT_UPDATE_MAGIC;
+
+		pdi_download_request.last_chunk = PDI_CHUNK_IS_LAST(flags);
+		pdi_download_request.chunk = PDI_CHUNK(flags);
+		pdi_download_request.chunk_size = PDI_CHUNK_SIZE;
+		/* Set longer timeout for the PDI download */
+		amc_proxy_cmd->cmd_timeout_jiffies = jiffies + REQUEST_DOWNLOAD_TIMEOUT;
+		ret = amc_proxy_request_pdi_download(amc_proxy_cmd, &pdi_download_request);
+
+	}
+	break;
+
+	case AMC_CMD_ID_DOWNLOAD_PARTIAL_PDI:
+	{
+		struct amc_proxy_pdi_download_request pdi_download_request = { 0 };
+		pdi_download_request.length = payload_size;
+		pdi_download_request.address = payload_address;
+		pdi_download_request.boot_device = PDI_BOOT_DEVICE(flags);
+		pdi_download_request.partial = true;
 
 		/* Using the `flags` argument to select the partition. */
 		if (PDI_PARTITION(flags) != FPT_UPDATE_FLAG)
@@ -1674,6 +1731,9 @@ int submit_gcq_command(struct amc_control_ctxt	*amc_ctrl_ctxt,
 		ret = amc_proxy_get_response_debug_verbosity(amc_proxy_cmd);
 		break;
 
+	case AMC_CMD_ID_DOWNLOAD_PARTIAL_PDI:
+		ret = amc_proxy_get_response_pdi_download(amc_proxy_cmd);
+		break;
 	default:
 		AMI_ERR(amc_ctrl_ctxt, "Unsupported response %d", cmd_id);
 		break;
diff --git a/sw/AMI/driver/ami_amc_control.h b/sw/AMI/driver/ami_amc_control.h
index 5828031..75ca259 100644
--- a/sw/AMI/driver/ami_amc_control.h
+++ b/sw/AMI/driver/ami_amc_control.h
@@ -140,6 +140,7 @@ enum gcq_submit_cmd_req {
 	GCQ_SUBMIT_CMD_DOWNLOAD_PDI			= 0x04,
 	GCQ_SUBMIT_CMD_DEVICE_BOOT			= 0x05,
 	GCQ_SUBMIT_CMD_COPY_PARTITION			= 0x06,
+	GCQ_SUBMIT_CMD_DOWNLOAD_PARTIAL_PDI		= 0x07,
 	GCQ_SUBMIT_CMD_GET_INLET_TEMP_SENSOR		= 0x10,
 	GCQ_SUBMIT_CMD_GET_OUTLET_TEMP_SENSOR		= 0x11,
 	GCQ_SUBMIT_CMD_GET_BOARD_TEMP_SENSOR		= 0x12,
@@ -359,6 +360,7 @@ enum amc_cmd_id {
 	AMC_CMD_ID_EEPROM_READ_WRITE,
 	AMC_CMD_ID_MODULE_READ_WRITE,
 	AMC_CMD_ID_DEBUG_VERBOSITY,
+	AMC_CMD_ID_DOWNLOAD_PARTIAL_PDI,
 
 	AMC_CMD_ID_MAX
 };
diff --git a/sw/AMI/driver/ami_cdev.c b/sw/AMI/driver/ami_cdev.c
index a332f7f..63453d1 100644
--- a/sw/AMI/driver/ami_cdev.c
+++ b/sw/AMI/driver/ami_cdev.c
@@ -5,793 +5,800 @@
  * Copyright (c) 2023 Advanced Micro Devices, Inc. All rights reserved.
  */
 
-#include <linux/pci.h>     /* pci_dev */
-#include <linux/errno.h>   /* error codes */
-#include <linux/kernel.h>  /* container_of */
-#include <linux/slab.h>    /* kzalloc... */
-#include <linux/string.h>  /* string funcs */
-#include <linux/fs.h>      /* file_operations */
-#include <linux/types.h>
-#include <linux/hwmon.h>
-#include <linux/eventfd.h>
-
-#include "ami.h"
-#include "ami_hwmon.h"
-#include "ami_top.h"
-#include "ami_cdev.h"
-#include "ami_utils.h"
-#include "ami_pcie.h"
-#include "ami_program.h"
-#include "ami_eeprom.h"
-#include "ami_utils.h"
-#include "ami_module.h"
-
-#define ROOT_USER                (0)
-#define READ_WRITE               (0666)
-#define IS_ROOT_USER(uid, euid)  (capable(CAP_DAC_OVERRIDE) || (uid == ROOT_USER) || (euid == ROOT_USER))
-
-
-static int dev_major = 0;  /* This will be overriden. */
-
-
-/**
- * devnode() - Callback to return device permissions.
- * @dev: Pointer to device struct.
- * @mode: Pointer to store permission bits.
- * 
- * Return: NULL.
- */
-static char *devnode(struct device *dev, umode_t *mode)
-{
-	if (mode)
-		*mode = READ_WRITE;
-
-	return NULL;
-}
-
-/*
- * Open a device file - this increments the pf_dev refcount.
- */
-int dev_open(struct inode *inode, struct file *filp)
-{
-	if (!inode || !filp)
-		return -EINVAL;
-	
-	/* This already checks the minor number */
-	filp->private_data = get_pf_dev_entry((void*)inode, PF_DEV_CACHE_INODE);
-
-	if (!filp->private_data)
-		return -ENODEV;
-
-	return 0;
-}
-
-/*
- * Close a device file - this decrements the pf_dev refcount.
- */
-int dev_close(struct inode *inode, struct file *filp)
-{
-	if (!inode || !filp)
-		return -EINVAL;
-
-	if (filp->private_data)
-		put_pf_dev_entry((struct pf_dev_struct*)filp->private_data);
-
-	return 0;
-}
-
-/*
- * This function will be called when we use IOCTL with command on the Device file
- */
-long dev_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	int ret = 0;
-	struct pf_dev_struct *pf_dev = NULL;
-	/* eventfd is used for sending notifications to the user */
-	struct eventfd_ctx *efd_ctx = NULL;
-
-	if (!filp)
-		return -EINVAL;
-
-	/*
-	 * Extract the type and number bitfields, and don't decode
-	 * wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok(  )
-	 */
-	if(_IOC_TYPE(cmd) != AMI_IOC_MAGIC) return -ENOTTY;
-	if(_IOC_NR(cmd) > AMI_IOC_MAX) return -ENOTTY;
-
-	if(!access_ok((void __user*)arg, _IOC_SIZE(cmd)))
-		return -ENOTTY;
-	
-	/* This is is already reference counted  */
-	pf_dev = filp->private_data;
-
-	/* Check device data */
-	if (!pf_dev) {
-		PR_ERR("dev_unlocked_ioctl: unable to find card");
-		return -ENODEV;
-	}
-
-	/* Check device state */
-	switch (cmd) {
-	/* READY, MISSING_INFO or COMPAT only */
-	case AMI_IOC_DOWNLOAD_PDI:
-	case AMI_IOC_DEVICE_BOOT:
-		switch (pf_dev->state) {
-		case PF_DEV_STATE_COMPAT:
-		case PF_DEV_STATE_READY:
-		case PF_DEV_STATE_MISSING_INFO:
-			break;
-		
-		default:
-			return -EPERM;
-		}
-		break;
-
-	/* Any state except INIT and SHUTDOWN */
-	case AMI_IOC_READ_BAR:
-	case AMI_IOC_WRITE_BAR:
-	case AMI_IOC_APP_SETUP:
-		switch (pf_dev->state) {
-		case PF_DEV_STATE_INIT:
-		case PF_DEV_STATE_SHUTDOWN:
-			return -EPERM;
-
-		default:
-			break;
-		}
-		break;
-
-	/* READY or MISSING_INFO only */
-	case AMI_IOC_GET_SENSOR_VALUE:
-	case AMI_IOC_COPY_PARTITION:
-	case AMI_IOC_SET_SENSOR_REFRESH:
-	case AMI_IOC_GET_FPT_HDR:
-	case AMI_IOC_GET_FPT_PARTITION:
-	case AMI_IOC_READ_EEPROM:
-	case AMI_IOC_WRITE_EEPROM:
-	case AMI_IOC_READ_MODULE:
-	case AMI_IOC_WRITE_MODULE:
-	case AMI_IOC_DEBUG_VERBOSITY:
-		switch (pf_dev->state) {
-		case PF_DEV_STATE_READY:
-		case PF_DEV_STATE_MISSING_INFO:
-			break;
-		
-		default:
-			return -EPERM;
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	/* Acquire semaphore */
-	if (down_interruptible(&(pf_dev->ioctl_sema)))
-		return -ERESTARTSYS;
-	
-	if (pf_dev->state == PF_DEV_STATE_COMPAT)
-		PR_WARN("Performing IOCTL request in compatibility mode - you may experience issues!");
-
-	/* Handle command */
-	switch (cmd) {
-	case AMI_IOC_SET_SENSOR_REFRESH:
-	{
-		/*
-		 * This does the same thing as writing to the `update_interval`
-		 * hwmon file, but we do not require any sudo permissions here.
-		 */
-		pf_dev->sensor_refresh = (uint16_t)arg;
-		break;
-	}
-
-	case AMI_IOC_DOWNLOAD_PDI:
-	{
-		/*
-		 * `arg` is a pointer to the `ami_ioc_data_payload` struct
-		 * This struct contains the address of the actual data buffer.
-		 */
-		struct ami_ioc_data_payload data = { 0 };
-		uint8_t *buf = NULL;
-
-		/* Check PF - currently only PF0 supported for this command. */
-		if (pf_dev->pcie_function_num != 0) {
-			ret = -ENODEV;
-			goto done;
-		}
-
-		/* Read data payload from user. */
-		if (copy_from_user(&data, (struct ami_ioc_data_payload*)arg, sizeof(data))) {
-			ret = -EFAULT; /* Bad address */
-			goto done;
-		}
-
-		/* Check permissions. */
-		if (!(data.cap_override || IS_ROOT_USER(current_uid().val, current_euid().val))) {
-			ret = -EPERM;
-			goto done;
-		}
-		
-		if ((data.size <= 0) || (data.addr == 0)) {
-			ret = -EINVAL;
-			goto done;
-		}
-
-		/*
-		 * Using vzalloc because the PDI buffer will be too large
-		 * for kzalloc (around 4-6MB)
-		 */
-		buf = vzalloc(data.size);
-
-		if (!buf) {
-			ret = -ENOMEM;
-			goto done;
-		}
-
-		if (data.efd >= 0)
-			efd_ctx = eventfd_ctx_fdget(data.efd);
-
-		/* Read actual data buffer. `addr` is a pointer to uint8_t */
-		if(!copy_from_user(buf, (uint8_t*)data.addr, data.size)) {
-			if (data.partition == AMI_IOC_FPT_UPDATE_MAGIC)
-				ret = update_fpt(
-					pf_dev,
-					buf,
-					data.size,
-					data.boot_device,
-					efd_ctx
-				);
-			else
-				ret = download_pdi(
-					pf_dev->amc_ctrl_ctxt,
-					buf,
-					data.size,
-					data.boot_device,
-					data.partition,
-					efd_ctx
-				);
-		} else {
-			ret = -EFAULT;
-		}
-
-		vfree(buf);
-		break;
-	}
-
-	case AMI_IOC_DEVICE_BOOT:
-	{
-		/*
-		 * `arg` is a pointer to the `ami_ioc_data_payload` struct.
-		 * Only the `partition` field should be populated.
-		 */
-		struct ami_ioc_data_payload data = { 0 };
-
-		/* Check PF - currently only PF0 supported for this command. */
-		if (pf_dev->pcie_function_num != 0) {
-			ret = -ENODEV;
-			goto done;
-		}
-
-		/* Read data payload from user. */
-		if (copy_from_user(&data, (struct ami_ioc_data_payload*)arg, sizeof(data))) {
-			ret = -EFAULT; /* Bad address */
-			goto done;
-		}
-
-		/* Check permissions. */
-		if (!(data.cap_override || IS_ROOT_USER(current_uid().val, current_euid().val))) {
-			ret = -EPERM;
-			goto done;
-		}
-
-		ret = device_boot(pf_dev, data.partition);
-
-		break;
-	}
-
-	case AMI_IOC_COPY_PARTITION:
-	{
-		/*
-		 * `arg` is a pointer to the `ami_ioc_data_payload` struct.
-		 * Only the `partition` field should be populated.
-		 */
-		struct ami_ioc_data_payload data = { 0 };
-
-		/* Check PF - currently only PF0 supported for this command. */
-		if (pf_dev->pcie_function_num != 0) {
-			ret = -ENODEV;
-			goto done;
-		}
-
-		/* Read data payload from user. */
-		if (copy_from_user(&data, (struct ami_ioc_data_payload*)arg, sizeof(data))) {
-			ret = -EFAULT; /* Bad address */
-			goto done;
-		}
-
-		/* Check permissions. */
-		if (!(data.cap_override || IS_ROOT_USER(current_uid().val, current_euid().val))) {
-			ret = -EPERM;
-			goto done;
-		}
-
-		ret = copy_partition(pf_dev, data.src_device, data.src_part, data.dest_device, data.dest_part);
-		break;
-	}
-
-        case AMI_IOC_READ_BAR:
-	{
-		/*
-		 * `arg` is a pointer to the `ami_ioc_bar_data` struct.
-		 */
-		uint32_t *buf = NULL;
-		struct ami_ioc_bar_data data = { 0 };
-
-		/* Read data payload. */
-		if (copy_from_user(&data, (struct ami_ioc_bar_data*)arg, sizeof(data))) {
-			ret = -EFAULT;
-			goto done;
-		}
-
-		/* Check permissions. */
-		if (!(data.cap_override || IS_ROOT_USER(current_uid().val, current_euid().val))) {
-			ret = -EPERM;
-			goto done;
-		}
-
-		if ((data.num <= 0) || (data.addr == 0)) {
-			ret = -EINVAL;
-			goto done;
-		}
-
-		/* Allocate memory for response buffer. */
-		buf = vzalloc(data.num * sizeof(uint32_t));
-
-		if (!buf) {
-			ret = -ENOMEM;
-			goto done;
-		}
-		
-		/* We will write the response to the userspace address. */
-		ret = read_pcie_bar(pf_dev->pci, data.bar_idx,
-			data.offset, data.num, buf);
-
-		if (!ret)
-			ret = copy_to_user((uint32_t*)data.addr, buf,
-				data.num * sizeof(uint32_t));
-
-		vfree(buf);
-		break;
-	}
-
-	case AMI_IOC_WRITE_BAR:
-	{
-		/*
-		 * `arg` is a pointer to the `ami_ioc_bar_data` struct.
-		 */
-		uint32_t *buf = NULL;
-		struct ami_ioc_bar_data data = { 0 };
-
-		/* Read data payload. */
-		if (copy_from_user(&data, (struct ami_ioc_bar_data*)arg, sizeof(data))) {
-			ret = -EFAULT;
-			goto done;
-		}
-
-		/* Check permissions. */
-		if (!(data.cap_override || IS_ROOT_USER(current_uid().val, current_euid().val))) {
-			ret = -EPERM;
-			goto done;
-		}
-
-		if ((data.num <= 0) || (data.addr == 0)) {
-			ret = -EINVAL;
-			goto done;
-		}
-		
-		/* Allocate memory for payload buffer. */
-		buf = vzalloc(data.num * sizeof(uint32_t));
-
-		if (!buf) {
-			ret = -ENOMEM;
-			goto done;
-		}
-		
-		/* Copy payload data. */
-		if (!copy_from_user(buf, (uint32_t*)data.addr, data.num * sizeof(uint32_t)))
-			ret = write_pcie_bar(pf_dev->pci, data.bar_idx,
-				data.offset, data.num, buf);
-		else
-			ret = -EFAULT;
-		
-		vfree(buf);
-		break;
-	}
-
-	case AMI_IOC_GET_SENSOR_VALUE:
-	{
-		/* `arg` is a pointer to `struct ami_ioc_sensor_value` */
-		struct ami_ioc_sensor_value data = { 0 };
-		enum hwmon_sensor_types hwmon_type = 0;
-		uint32_t hwmon_attr = 0;
-
-		if (copy_from_user(&data, (struct ami_ioc_sensor_value*)arg, sizeof(data))) {
-			ret = -EFAULT;
-			goto done;
-		}
-
-		/* Currently, only the instant sensor value is supported with this API. */
-		switch (data.sensor_type) {
-		case IOC_SENSOR_TYPE_TEMP:
-			hwmon_type = hwmon_temp;
-			hwmon_attr = hwmon_temp_input;
-			break;
-		
-		case IOC_SENSOR_TYPE_POWER:
-			hwmon_type = hwmon_power;
-			hwmon_attr = hwmon_power_input;
-			break;
-		
-		case IOC_SENSOR_TYPE_CURRENT:
-			hwmon_type = hwmon_curr;
-			hwmon_attr = hwmon_curr_input;
-			break;
-		
-		case IOC_SENSOR_TYPE_VOLTAGE:
-			hwmon_type = hwmon_in;
-			hwmon_attr = hwmon_in_input;
-			break;
-		
-		default:
-			ret = -EINVAL;
-			break;
-		}
-
-		if (ret)
-			goto done;
-
-		ret = read_sensor_val(
-			pf_dev,
-			hwmon_type,
-			hwmon_attr,
-			data.hwmon_channel,
-			&data.val,
-			data.status,
-			&data.fresh
-		);
-
-		if (!ret)
-			ret = copy_to_user((struct ami_ioc_sensor_value*)arg,
-				&data, sizeof(data));
-
-		break;
-	}
-
-	case AMI_IOC_GET_FPT_HDR:
-	{
-                /* `arg` is a pointer to `struct ami_ioc_fpt_hdr_value` */
-                struct ami_ioc_fpt_hdr_value data = { 0 };
-                struct fpt_header hdr = { 0 };
-
-		/* Read data payload from user. */
-		if (copy_from_user(&data, (struct ami_ioc_fpt_hdr_value*)arg, sizeof(data))) {
-			ret = -EFAULT;
-			goto done;
-		}	
-
-                ret = read_fpt_hdr(pf_dev, data.boot_device, &hdr);
-                if (!ret) {
-                        data.version = hdr.version;
-                        data.hdr_size = hdr.header_size;
-                        data.entry_size = hdr.entry_size;
-                        data.num_entries = hdr.num_entries;
-                        ret = copy_to_user((struct ami_ioc_fpt_hdr_value*)arg,
-					   &data, sizeof(data));
-                }
-                break;
-	}
-
-	case AMI_IOC_GET_FPT_PARTITION:
-	{
-                /* `arg` is a pointer to `struct ami_ioc_fpt_partition_value` */
-                struct ami_ioc_fpt_partition_value data = { 0 };
-                struct fpt_partition partition = { 0 };
-
-                if (copy_from_user(&data, (struct ami_ioc_fpt_partition_value*)arg, sizeof(data))) {
-                        ret = -EFAULT;
-                        goto done;
-                }
-
-                ret = read_fpt_partition(pf_dev,
+ #include <linux/version.h>
+ #include <linux/pci.h>     /* pci_dev */
+ #include <linux/errno.h>   /* error codes */
+ #include <linux/kernel.h>  /* container_of */
+ #include <linux/slab.h>    /* kzalloc... */
+ #include <linux/string.h>  /* string funcs */
+ #include <linux/fs.h>      /* file_operations */
+ #include <linux/types.h>
+ #include <linux/hwmon.h>
+ #include <linux/eventfd.h>
+ 
+ #include "ami.h"
+ #include "ami_hwmon.h"
+ #include "ami_top.h"
+ #include "ami_cdev.h"
+ #include "ami_utils.h"
+ #include "ami_pcie.h"
+ #include "ami_program.h"
+ #include "ami_eeprom.h"
+ #include "ami_utils.h"
+ #include "ami_module.h"
+ 
+ #define ROOT_USER                (0)
+ #define READ_WRITE               (0666)
+ #define IS_ROOT_USER(uid, euid)  (capable(CAP_DAC_OVERRIDE) || (uid == ROOT_USER) || (euid == ROOT_USER))
+ 
+ 
+ static int dev_major = 0;  /* This will be overriden. */
+ 
+ 
+ /**
+  * devnode() - Callback to return device permissions.
+  * @dev: Pointer to device struct.
+  * @mode: Pointer to store permission bits.
+  * 
+  * Return: NULL.
+  */
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+ static char *devnode(const struct device *dev, umode_t *mode)
+ #else
+ static char *devnode(struct device *dev, umode_t *mode)
+ #endif
+ {
+	 if (mode)
+		 *mode = READ_WRITE;
+ 
+	 return NULL;
+ }
+ 
+ /*
+  * Open a device file - this increments the pf_dev refcount.
+  */
+ int dev_open(struct inode *inode, struct file *filp)
+ {
+	 if (!inode || !filp)
+		 return -EINVAL;
+	 
+	 /* This already checks the minor number */
+	 filp->private_data = get_pf_dev_entry((void*)inode, PF_DEV_CACHE_INODE);
+ 
+	 if (!filp->private_data)
+		 return -ENODEV;
+ 
+	 return 0;
+ }
+ 
+ /*
+  * Close a device file - this decrements the pf_dev refcount.
+  */
+ int dev_close(struct inode *inode, struct file *filp)
+ {
+	 if (!inode || !filp)
+		 return -EINVAL;
+ 
+	 if (filp->private_data)
+		 put_pf_dev_entry((struct pf_dev_struct*)filp->private_data);
+ 
+	 return 0;
+ }
+ 
+ /*
+  * This function will be called when we use IOCTL with command on the Device file
+  */
+ long dev_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+ {
+	 int ret = 0;
+	 struct pf_dev_struct *pf_dev = NULL;
+	 /* eventfd is used for sending notifications to the user */
+	 struct eventfd_ctx *efd_ctx = NULL;
+ 
+	 if (!filp)
+		 return -EINVAL;
+ 
+	 /*
+	  * Extract the type and number bitfields, and don't decode
+	  * wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok(  )
+	  */
+	 if(_IOC_TYPE(cmd) != AMI_IOC_MAGIC) return -ENOTTY;
+	 if(_IOC_NR(cmd) > AMI_IOC_MAX) return -ENOTTY;
+ 
+	 if(!access_ok((void __user*)arg, _IOC_SIZE(cmd)))
+		 return -ENOTTY;
+	 
+	 /* This is is already reference counted  */
+	 pf_dev = filp->private_data;
+ 
+	 /* Check device data */
+	 if (!pf_dev) {
+		 PR_ERR("dev_unlocked_ioctl: unable to find card");
+		 return -ENODEV;
+	 }
+ 
+	 /* Check device state */
+	 switch (cmd) {
+	 /* READY, MISSING_INFO or COMPAT only */
+	 case AMI_IOC_DOWNLOAD_PDI:
+	 case AMI_IOC_DEVICE_BOOT:
+		 switch (pf_dev->state) {
+		 case PF_DEV_STATE_COMPAT:
+		 case PF_DEV_STATE_READY:
+		 case PF_DEV_STATE_MISSING_INFO:
+			 break;
+		 
+		 default:
+			 return -EPERM;
+		 }
+		 break;
+ 
+	 /* Any state except INIT and SHUTDOWN */
+	 case AMI_IOC_READ_BAR:
+	 case AMI_IOC_WRITE_BAR:
+	 case AMI_IOC_APP_SETUP:
+		 switch (pf_dev->state) {
+		 case PF_DEV_STATE_INIT:
+		 case PF_DEV_STATE_SHUTDOWN:
+			 return -EPERM;
+ 
+		 default:
+			 break;
+		 }
+		 break;
+ 
+	 /* READY or MISSING_INFO only */
+	 case AMI_IOC_GET_SENSOR_VALUE:
+	 case AMI_IOC_COPY_PARTITION:
+	 case AMI_IOC_SET_SENSOR_REFRESH:
+	 case AMI_IOC_GET_FPT_HDR:
+	 case AMI_IOC_GET_FPT_PARTITION:
+	 case AMI_IOC_READ_EEPROM:
+	 case AMI_IOC_WRITE_EEPROM:
+	 case AMI_IOC_READ_MODULE:
+	 case AMI_IOC_WRITE_MODULE:
+	 case AMI_IOC_DEBUG_VERBOSITY:
+		 switch (pf_dev->state) {
+		 case PF_DEV_STATE_READY:
+		 case PF_DEV_STATE_MISSING_INFO:
+			 break;
+		 
+		 default:
+			 return -EPERM;
+		 }
+		 break;
+ 
+	 default:
+		 break;
+	 }
+ 
+	 /* Acquire semaphore */
+	 if (down_interruptible(&(pf_dev->ioctl_sema)))
+		 return -ERESTARTSYS;
+	 
+	 if (pf_dev->state == PF_DEV_STATE_COMPAT)
+		 PR_WARN("Performing IOCTL request in compatibility mode - you may experience issues!");
+ 
+	 /* Handle command */
+	 switch (cmd) {
+	 case AMI_IOC_SET_SENSOR_REFRESH:
+	 {
+		 /*
+		  * This does the same thing as writing to the `update_interval`
+		  * hwmon file, but we do not require any sudo permissions here.
+		  */
+		 pf_dev->sensor_refresh = (uint16_t)arg;
+		 break;
+	 }
+ 
+	 case AMI_IOC_DOWNLOAD_PDI:
+	 {
+		 /*
+		  * `arg` is a pointer to the `ami_ioc_data_payload` struct
+		  * This struct contains the address of the actual data buffer.
+		  */
+		 struct ami_ioc_data_payload data = { 0 };
+		 uint8_t *buf = NULL;
+ 
+		 /* Check PF - currently only PF0 supported for this command. */
+		 if (pf_dev->pcie_function_num != 0) {
+			 ret = -ENODEV;
+			 goto done;
+		 }
+ 
+		 /* Read data payload from user. */
+		 if (copy_from_user(&data, (struct ami_ioc_data_payload*)arg, sizeof(data))) {
+			 ret = -EFAULT; /* Bad address */
+			 goto done;
+		 }
+ 
+		 /* Check permissions. */
+		 if (!(data.cap_override || IS_ROOT_USER(current_uid().val, current_euid().val))) {
+			 ret = -EPERM;
+			 goto done;
+		 }
+		 
+		 if ((data.size <= 0) || (data.addr == 0)) {
+			 ret = -EINVAL;
+			 goto done;
+		 }
+ 
+		 /*
+		  * Using vzalloc because the PDI buffer will be too large
+		  * for kzalloc (around 4-6MB)
+		  */
+		 buf = vzalloc(data.size);
+ 
+		 if (!buf) {
+			 ret = -ENOMEM;
+			 goto done;
+		 }
+ 
+		 if (data.efd >= 0)
+			 efd_ctx = eventfd_ctx_fdget(data.efd);
+ 
+		 /* Read actual data buffer. `addr` is a pointer to uint8_t */
+		 if(!copy_from_user(buf, (uint8_t*)data.addr, data.size)) {
+			 if (data.partition == AMI_IOC_FPT_UPDATE_MAGIC)
+				 ret = update_fpt(
+					 pf_dev,
+					 buf,
+					 data.size,
 					 data.boot_device,
-                                         data.partition,
-                                         &partition);
-                if (!ret) {
-                        data.type = partition.type;
-                        data.base_addr = partition.base_addr;
-                        data.partition_size = partition.partition_size;
-                        ret = copy_to_user((struct ami_ioc_fpt_partition_value*)arg,
-					   &data, sizeof(data));
-                }
-                break;
-	}
-
-        case AMI_IOC_READ_EEPROM:
-        {
-                struct ami_ioc_eeprom_payload data = { 0 };
-                uint8_t *buf = NULL;
-
-                /* Read data payload. */
-                if (copy_from_user(&data, (struct ami_ioc_eeprom_payload*)arg, sizeof(data))) {
-                        ret = -EFAULT;
-                        goto done;
-                }
-
-                if ((data.len <= 0) || (data.addr == 0)) {
-			ret = -EINVAL;
-			goto done;
-		}
-
-                /* Allocate memory for response buffer. */
-		buf = vzalloc(data.len * sizeof(uint8_t));
-
-		if (!buf) {
-			ret = -ENOMEM;
-			goto done;
-		}
-
-                ret = eeprom_read(pf_dev->amc_ctrl_ctxt, buf, data.len, data.offset);
-                if (!ret) {
-                        ret = copy_to_user((uint8_t*)data.addr, buf,
-				data.len * sizeof(uint8_t));
-                }
-                vfree(buf);
-                break;
-        }
-
-        case AMI_IOC_WRITE_EEPROM:
-        {
-                struct ami_ioc_eeprom_payload data = { 0 };
-		uint8_t *buf = NULL;
-
-		/* Read data payload. */
-		if (copy_from_user(&data, (struct ami_ioc_eeprom_payload*)arg, sizeof(data))) {
-			ret = -EFAULT;
-			goto done;
-		}
-
-		if ((data.len <= 0) || (data.addr == 0)) {
-			ret = -EINVAL;
-			goto done;
-		}
-
-		/* Allocate memory for payload buffer. */
-		buf = vzalloc(data.len * sizeof(uint8_t));
-
-		if (!buf) {
-			ret = -ENOMEM;
-			goto done;
-		}
-
-		/* Copy payload data. */
-		if (!copy_from_user(buf, (uint8_t*)data.addr, data.len * sizeof(uint8_t)))
-			ret = eeprom_write(pf_dev->amc_ctrl_ctxt, buf, data.len, data.offset);
-                else
-			ret = -EFAULT;
-
-		vfree(buf);
-                break;
-        }
-
-	case AMI_IOC_APP_SETUP:
-		switch ((enum ami_ioc_app_setup)arg) {
-		case IOC_APP_SETUP_REGISTER:
-			ret = add_pf_dev_app(pf_dev, get_current());
-			break;
-		
-		case IOC_APP_SETUP_DEREGISTER:
-			ret = delete_pf_dev_app(pf_dev, get_current());
-			break;
-		
-		default:
-			ret = -EINVAL;
-			break;
-		}
-		break;
-
-	case AMI_IOC_READ_MODULE:
-	{
-		struct ami_ioc_module_payload data = { 0 };
-		uint8_t *buf = NULL;
-
-		/* Read data payload. */
-		if (copy_from_user(&data, (struct ami_ioc_module_payload*)arg, sizeof(data))) {
-			ret = -EFAULT;
-			goto done;
-		}
-
-		if ((data.len <= 0) || (data.addr == 0)) {
-			ret = -EINVAL;
-			goto done;
-		}
-
-		/* Allocate memory for response buffer. */
-		buf = vzalloc(data.len * sizeof(uint8_t));
-
-		if (!buf) {
-			ret = -ENOMEM;
-			goto done;
-		}
-
-		ret = module_read(
-			pf_dev->amc_ctrl_ctxt,
-			data.device_id,
-			data.page,
-			data.offset,
-			buf,
-			data.len
-		);
-
-		if (!ret) {
-			ret = copy_to_user((uint8_t*)data.addr, buf,
-				data.len * sizeof(uint8_t));
-		}
-		vfree(buf);
-		break;
-	}
-
-	case AMI_IOC_WRITE_MODULE:
-	{
-		struct ami_ioc_module_payload data = { 0 };
-		uint8_t *buf = NULL;
-
-		/* Read data payload. */
-		if (copy_from_user(&data, (struct ami_ioc_module_payload*)arg, sizeof(data))) {
-			ret = -EFAULT;
-			goto done;
-		}
-
-		if ((data.len <= 0) || (data.addr == 0)) {
-			ret = -EINVAL;
-			goto done;
-		}
-
-		/* Allocate memory for payload buffer. */
-		buf = vzalloc(data.len * sizeof(uint8_t));
-
-		if (!buf) {
-			ret = -ENOMEM;
-			goto done;
-		}
-
-		/* Copy payload data. */
-		if (!copy_from_user(buf, (uint8_t*)data.addr, data.len * sizeof(uint8_t)))
-			ret = module_write(
-				pf_dev->amc_ctrl_ctxt,
-				data.device_id,
-				data.page,
-				data.offset,
-				buf,
-				data.len
-			);
-		else
-			ret = -EFAULT;
-
-		vfree(buf);
-		break;
-	}
-
-	case AMI_IOC_DEBUG_VERBOSITY:
-		ret = submit_gcq_command(
-			pf_dev->amc_ctrl_ctxt,
-			GCQ_SUBMIT_CMD_DEBUG_VERBOSITY,
-			(uint8_t)arg,
-			NULL,
-			0
-		);
-		break;
-
-	default:
-		PR_ERR("Unknown command, do nothing");
-		ret = -ENOTTY;
-		break;
-	}
-
-done:
-	if (efd_ctx)
-		eventfd_ctx_put(efd_ctx);
-
-	up(&(pf_dev->ioctl_sema));
-	return ret;
-}
-
-/*
- * Create a character device.
- */
-int create_cdev(unsigned baseminor, struct drv_cdev_struct *drv_cdev,
-	struct device *parent, const struct file_operations *fops)
-{
-	int ret = 0;
-	bool cls_created = false;
-
-	/* parent may be NULL */
-	if (!drv_cdev || !fops) {
-		return -EINVAL;
-	}
-
-	/* Allocate chrdev region */
-	drv_cdev->count = DEFAULT_CDEV_COUNT;
-	if(dev_major) {
-		drv_cdev->cdev_num = MKDEV(dev_major, baseminor);
-		ret = register_chrdev_region(drv_cdev->cdev_num, DEFAULT_CDEV_COUNT,
-			(const char*)DEFAULT_DEVICE_NAME);
-	} else {
-		/* This is the first device. */
-		ret = alloc_chrdev_region(&(drv_cdev->cdev_num), baseminor,
-			 DEFAULT_CDEV_COUNT, (const char*)DEFAULT_DEVICE_NAME);
-		dev_major = MAJOR(drv_cdev->cdev_num);
-	}
-
-	if(ret)
-		goto fail;
-
-	/* If first device, create class. */
-	strncpy(drv_cdev->drv_cls_str, (const char*)DEFAULT_CLS_NAME, CLS_STR_SIZE);
-
-	if(!drv_cdev->dev_class) {
-		cls_created = true;
-		drv_cdev->dev_class = class_create(THIS_MODULE, drv_cdev->drv_cls_str);
-		if (IS_ERR(drv_cdev->dev_class)) {
-			ret = PTR_ERR(drv_cdev->dev_class);
-			PR_ERR("Failed to create class %s. ret : %d",
-				drv_cdev->drv_cls_str, ret);
-			goto unreg_cdev_reg;
-		}
-		drv_cdev->dev_class->devnode = devnode;
-	}
-
-	/* Create device */
-	snprintf(drv_cdev->dev_name, DEV_NAME_SIZE, "%s%d", DEFAULT_DEVICE_NAME, baseminor);
-	drv_cdev->device = device_create(drv_cdev->dev_class, NULL,
-		drv_cdev->cdev_num, NULL, drv_cdev->dev_name);
-	if (IS_ERR(drv_cdev->device)) {
-		ret = PTR_ERR(drv_cdev->device);
-		PR_ERR("Failed to create device %s. ret : %d", drv_cdev->dev_name, ret);
-		goto del_class;
-	}
-
-	/* Initialize the cdev structure */
-	cdev_init(&(drv_cdev->cdev), fops);
-	drv_cdev->cdev.owner = THIS_MODULE;
-	drv_cdev->cdev.ops = fops;
-
-	/*
-	 * Setting the parent is necessary so that the kobject is referenced
-	 * appropriately and the parent is not freed before the cdev.
-	 */
-	if (parent)
-		cdev_set_parent(&drv_cdev->cdev, &parent->kobj);
-	
-	/* Register cdev to the kernel */
-	ret = cdev_add(&(drv_cdev->cdev), drv_cdev->cdev_num, drv_cdev->count);
-	if (ret) {
-		PR_ERR("Failed to register cdev to the kernel, err_code : %d", ret);
-		goto del_device;
-	}
-
-	return SUCCESS;
-
-del_device:
-	device_destroy(drv_cdev->dev_class, drv_cdev->cdev_num);
-
-del_class:
-	if(cls_created)
-		class_destroy(drv_cdev->dev_class);
-
-unreg_cdev_reg:
-	unregister_chrdev_region(drv_cdev->cdev_num, DEFAULT_CDEV_COUNT);
-
-fail:
-	return ret;
-}
+					 efd_ctx
+				 );
+			 else
+				 ret = download_pdi(
+					 pf_dev->amc_ctrl_ctxt,
+					 buf,
+					 data.size,
+					 data.boot_device,
+					 data.partition,
+					 efd_ctx,
+					 data.partial ? true : false
+				 );
+		 } else {
+			 ret = -EFAULT;
+		 }
+ 
+		 vfree(buf);
+		 break;
+	 }
+ 
+	 case AMI_IOC_DEVICE_BOOT:
+	 {
+		 /*
+		  * `arg` is a pointer to the `ami_ioc_data_payload` struct.
+		  * Only the `partition` field should be populated.
+		  */
+		 struct ami_ioc_data_payload data = { 0 };
+ 
+		 /* Check PF - currently only PF0 supported for this command. */
+		 if (pf_dev->pcie_function_num != 0) {
+			 ret = -ENODEV;
+			 goto done;
+		 }
+ 
+		 /* Read data payload from user. */
+		 if (copy_from_user(&data, (struct ami_ioc_data_payload*)arg, sizeof(data))) {
+			 ret = -EFAULT; /* Bad address */
+			 goto done;
+		 }
+ 
+		 /* Check permissions. */
+		 if (!(data.cap_override || IS_ROOT_USER(current_uid().val, current_euid().val))) {
+			 ret = -EPERM;
+			 goto done;
+		 }
+ 
+		 ret = device_boot(pf_dev, data.partition);
+ 
+		 break;
+	 }
+ 
+	 case AMI_IOC_COPY_PARTITION:
+	 {
+		 /*
+		  * `arg` is a pointer to the `ami_ioc_data_payload` struct.
+		  * Only the `partition` field should be populated.
+		  */
+		 struct ami_ioc_data_payload data = { 0 };
+ 
+		 /* Check PF - currently only PF0 supported for this command. */
+		 if (pf_dev->pcie_function_num != 0) {
+			 ret = -ENODEV;
+			 goto done;
+		 }
+ 
+		 /* Read data payload from user. */
+		 if (copy_from_user(&data, (struct ami_ioc_data_payload*)arg, sizeof(data))) {
+			 ret = -EFAULT; /* Bad address */
+			 goto done;
+		 }
+ 
+		 /* Check permissions. */
+		 if (!(data.cap_override || IS_ROOT_USER(current_uid().val, current_euid().val))) {
+			 ret = -EPERM;
+			 goto done;
+		 }
+ 
+		 ret = copy_partition(pf_dev, data.src_device, data.src_part, data.dest_device, data.dest_part);
+		 break;
+	 }
+ 
+		 case AMI_IOC_READ_BAR:
+	 {
+		 /*
+		  * `arg` is a pointer to the `ami_ioc_bar_data` struct.
+		  */
+		 uint32_t *buf = NULL;
+		 struct ami_ioc_bar_data data = { 0 };
+ 
+		 /* Read data payload. */
+		 if (copy_from_user(&data, (struct ami_ioc_bar_data*)arg, sizeof(data))) {
+			 ret = -EFAULT;
+			 goto done;
+		 }
+ 
+		 /* Check permissions. */
+		 if (!(data.cap_override || IS_ROOT_USER(current_uid().val, current_euid().val))) {
+			 ret = -EPERM;
+			 goto done;
+		 }
+ 
+		 if ((data.num <= 0) || (data.addr == 0)) {
+			 ret = -EINVAL;
+			 goto done;
+		 }
+ 
+		 /* Allocate memory for response buffer. */
+		 buf = vzalloc(data.num * sizeof(uint32_t));
+ 
+		 if (!buf) {
+			 ret = -ENOMEM;
+			 goto done;
+		 }
+		 
+		 /* We will write the response to the userspace address. */
+		 ret = read_pcie_bar(pf_dev->pci, data.bar_idx,
+			 data.offset, data.num, buf);
+ 
+		 if (!ret)
+			 ret = copy_to_user((uint32_t*)data.addr, buf,
+				 data.num * sizeof(uint32_t));
+ 
+		 vfree(buf);
+		 break;
+	 }
+ 
+	 case AMI_IOC_WRITE_BAR:
+	 {
+		 /*
+		  * `arg` is a pointer to the `ami_ioc_bar_data` struct.
+		  */
+		 uint32_t *buf = NULL;
+		 struct ami_ioc_bar_data data = { 0 };
+ 
+		 /* Read data payload. */
+		 if (copy_from_user(&data, (struct ami_ioc_bar_data*)arg, sizeof(data))) {
+			 ret = -EFAULT;
+			 goto done;
+		 }
+ 
+		 /* Check permissions. */
+		 if (!(data.cap_override || IS_ROOT_USER(current_uid().val, current_euid().val))) {
+			 ret = -EPERM;
+			 goto done;
+		 }
+ 
+		 if ((data.num <= 0) || (data.addr == 0)) {
+			 ret = -EINVAL;
+			 goto done;
+		 }
+		 
+		 /* Allocate memory for payload buffer. */
+		 buf = vzalloc(data.num * sizeof(uint32_t));
+ 
+		 if (!buf) {
+			 ret = -ENOMEM;
+			 goto done;
+		 }
+		 
+		 /* Copy payload data. */
+		 if (!copy_from_user(buf, (uint32_t*)data.addr, data.num * sizeof(uint32_t)))
+			 ret = write_pcie_bar(pf_dev->pci, data.bar_idx,
+				 data.offset, data.num, buf);
+		 else
+			 ret = -EFAULT;
+		 
+		 vfree(buf);
+		 break;
+	 }
+ 
+	 case AMI_IOC_GET_SENSOR_VALUE:
+	 {
+		 /* `arg` is a pointer to `struct ami_ioc_sensor_value` */
+		 struct ami_ioc_sensor_value data = { 0 };
+		 enum hwmon_sensor_types hwmon_type = 0;
+		 uint32_t hwmon_attr = 0;
+ 
+		 if (copy_from_user(&data, (struct ami_ioc_sensor_value*)arg, sizeof(data))) {
+			 ret = -EFAULT;
+			 goto done;
+		 }
+ 
+		 /* Currently, only the instant sensor value is supported with this API. */
+		 switch (data.sensor_type) {
+		 case IOC_SENSOR_TYPE_TEMP:
+			 hwmon_type = hwmon_temp;
+			 hwmon_attr = hwmon_temp_input;
+			 break;
+		 
+		 case IOC_SENSOR_TYPE_POWER:
+			 hwmon_type = hwmon_power;
+			 hwmon_attr = hwmon_power_input;
+			 break;
+		 
+		 case IOC_SENSOR_TYPE_CURRENT:
+			 hwmon_type = hwmon_curr;
+			 hwmon_attr = hwmon_curr_input;
+			 break;
+		 
+		 case IOC_SENSOR_TYPE_VOLTAGE:
+			 hwmon_type = hwmon_in;
+			 hwmon_attr = hwmon_in_input;
+			 break;
+		 
+		 default:
+			 ret = -EINVAL;
+			 break;
+		 }
+ 
+		 if (ret)
+			 goto done;
+ 
+		 ret = read_sensor_val(
+			 pf_dev,
+			 hwmon_type,
+			 hwmon_attr,
+			 data.hwmon_channel,
+			 &data.val,
+			 data.status,
+			 &data.fresh
+		 );
+ 
+		 if (!ret)
+			 ret = copy_to_user((struct ami_ioc_sensor_value*)arg,
+				 &data, sizeof(data));
+ 
+		 break;
+	 }
+ 
+	 case AMI_IOC_GET_FPT_HDR:
+	 {
+				 /* `arg` is a pointer to `struct ami_ioc_fpt_hdr_value` */
+				 struct ami_ioc_fpt_hdr_value data = { 0 };
+				 struct fpt_header hdr = { 0 };
+ 
+		 /* Read data payload from user. */
+		 if (copy_from_user(&data, (struct ami_ioc_fpt_hdr_value*)arg, sizeof(data))) {
+			 ret = -EFAULT;
+			 goto done;
+		 }	
+ 
+				 ret = read_fpt_hdr(pf_dev, data.boot_device, &hdr);
+				 if (!ret) {
+						 data.version = hdr.version;
+						 data.hdr_size = hdr.header_size;
+						 data.entry_size = hdr.entry_size;
+						 data.num_entries = hdr.num_entries;
+						 ret = copy_to_user((struct ami_ioc_fpt_hdr_value*)arg,
+						&data, sizeof(data));
+				 }
+				 break;
+	 }
+ 
+	 case AMI_IOC_GET_FPT_PARTITION:
+	 {
+				 /* `arg` is a pointer to `struct ami_ioc_fpt_partition_value` */
+				 struct ami_ioc_fpt_partition_value data = { 0 };
+				 struct fpt_partition partition = { 0 };
+ 
+				 if (copy_from_user(&data, (struct ami_ioc_fpt_partition_value*)arg, sizeof(data))) {
+						 ret = -EFAULT;
+						 goto done;
+				 }
+ 
+				 ret = read_fpt_partition(pf_dev,
+					  data.boot_device,
+										  data.partition,
+										  &partition);
+				 if (!ret) {
+						 data.type = partition.type;
+						 data.base_addr = partition.base_addr;
+						 data.partition_size = partition.partition_size;
+						 ret = copy_to_user((struct ami_ioc_fpt_partition_value*)arg,
+						&data, sizeof(data));
+				 }
+				 break;
+	 }
+ 
+		 case AMI_IOC_READ_EEPROM:
+		 {
+				 struct ami_ioc_eeprom_payload data = { 0 };
+				 uint8_t *buf = NULL;
+ 
+				 /* Read data payload. */
+				 if (copy_from_user(&data, (struct ami_ioc_eeprom_payload*)arg, sizeof(data))) {
+						 ret = -EFAULT;
+						 goto done;
+				 }
+ 
+				 if ((data.len <= 0) || (data.addr == 0)) {
+			 ret = -EINVAL;
+			 goto done;
+		 }
+ 
+				 /* Allocate memory for response buffer. */
+		 buf = vzalloc(data.len * sizeof(uint8_t));
+ 
+		 if (!buf) {
+			 ret = -ENOMEM;
+			 goto done;
+		 }
+ 
+				 ret = eeprom_read(pf_dev->amc_ctrl_ctxt, buf, data.len, data.offset);
+				 if (!ret) {
+						 ret = copy_to_user((uint8_t*)data.addr, buf,
+				 data.len * sizeof(uint8_t));
+				 }
+				 vfree(buf);
+				 break;
+		 }
+ 
+		 case AMI_IOC_WRITE_EEPROM:
+		 {
+				 struct ami_ioc_eeprom_payload data = { 0 };
+		 uint8_t *buf = NULL;
+ 
+		 /* Read data payload. */
+		 if (copy_from_user(&data, (struct ami_ioc_eeprom_payload*)arg, sizeof(data))) {
+			 ret = -EFAULT;
+			 goto done;
+		 }
+ 
+		 if ((data.len <= 0) || (data.addr == 0)) {
+			 ret = -EINVAL;
+			 goto done;
+		 }
+ 
+		 /* Allocate memory for payload buffer. */
+		 buf = vzalloc(data.len * sizeof(uint8_t));
+ 
+		 if (!buf) {
+			 ret = -ENOMEM;
+			 goto done;
+		 }
+ 
+		 /* Copy payload data. */
+		 if (!copy_from_user(buf, (uint8_t*)data.addr, data.len * sizeof(uint8_t)))
+			 ret = eeprom_write(pf_dev->amc_ctrl_ctxt, buf, data.len, data.offset);
+				 else
+			 ret = -EFAULT;
+ 
+		 vfree(buf);
+				 break;
+		 }
+ 
+	 case AMI_IOC_APP_SETUP:
+		 switch ((enum ami_ioc_app_setup)arg) {
+		 case IOC_APP_SETUP_REGISTER:
+			 ret = add_pf_dev_app(pf_dev, get_current());
+			 break;
+		 
+		 case IOC_APP_SETUP_DEREGISTER:
+			 ret = delete_pf_dev_app(pf_dev, get_current());
+			 break;
+		 
+		 default:
+			 ret = -EINVAL;
+			 break;
+		 }
+		 break;
+ 
+	 case AMI_IOC_READ_MODULE:
+	 {
+		 struct ami_ioc_module_payload data = { 0 };
+		 uint8_t *buf = NULL;
+ 
+		 /* Read data payload. */
+		 if (copy_from_user(&data, (struct ami_ioc_module_payload*)arg, sizeof(data))) {
+			 ret = -EFAULT;
+			 goto done;
+		 }
+ 
+		 if ((data.len <= 0) || (data.addr == 0)) {
+			 ret = -EINVAL;
+			 goto done;
+		 }
+ 
+		 /* Allocate memory for response buffer. */
+		 buf = vzalloc(data.len * sizeof(uint8_t));
+ 
+		 if (!buf) {
+			 ret = -ENOMEM;
+			 goto done;
+		 }
+ 
+		 ret = module_read(
+			 pf_dev->amc_ctrl_ctxt,
+			 data.device_id,
+			 data.page,
+			 data.offset,
+			 buf,
+			 data.len
+		 );
+ 
+		 if (!ret) {
+			 ret = copy_to_user((uint8_t*)data.addr, buf,
+				 data.len * sizeof(uint8_t));
+		 }
+		 vfree(buf);
+		 break;
+	 }
+ 
+	 case AMI_IOC_WRITE_MODULE:
+	 {
+		 struct ami_ioc_module_payload data = { 0 };
+		 uint8_t *buf = NULL;
+ 
+		 /* Read data payload. */
+		 if (copy_from_user(&data, (struct ami_ioc_module_payload*)arg, sizeof(data))) {
+			 ret = -EFAULT;
+			 goto done;
+		 }
+ 
+		 if ((data.len <= 0) || (data.addr == 0)) {
+			 ret = -EINVAL;
+			 goto done;
+		 }
+ 
+		 /* Allocate memory for payload buffer. */
+		 buf = vzalloc(data.len * sizeof(uint8_t));
+ 
+		 if (!buf) {
+			 ret = -ENOMEM;
+			 goto done;
+		 }
+ 
+		 /* Copy payload data. */
+		 if (!copy_from_user(buf, (uint8_t*)data.addr, data.len * sizeof(uint8_t)))
+			 ret = module_write(
+				 pf_dev->amc_ctrl_ctxt,
+				 data.device_id,
+				 data.page,
+				 data.offset,
+				 buf,
+				 data.len
+			 );
+		 else
+			 ret = -EFAULT;
+ 
+		 vfree(buf);
+		 break;
+	 }
+ 
+	 case AMI_IOC_DEBUG_VERBOSITY:
+		 ret = submit_gcq_command(
+			 pf_dev->amc_ctrl_ctxt,
+			 GCQ_SUBMIT_CMD_DEBUG_VERBOSITY,
+			 (uint8_t)arg,
+			 NULL,
+			 0
+		 );
+		 break;
+ 
+	 default:
+		 PR_ERR("Unknown command, do nothing");
+		 ret = -ENOTTY;
+		 break;
+	 }
+ 
+ done:
+	 if (efd_ctx)
+		 eventfd_ctx_put(efd_ctx);
+ 
+	 up(&(pf_dev->ioctl_sema));
+	 return ret;
+ }
+ 
+ /*
+  * Create a character device.
+  */
+ int create_cdev(unsigned baseminor, struct drv_cdev_struct *drv_cdev,
+	 struct device *parent, const struct file_operations *fops)
+ {
+	 int ret = 0;
+	 bool cls_created = false;
+ 
+	 /* parent may be NULL */
+	 if (!drv_cdev || !fops) {
+		 return -EINVAL;
+	 }
+ 
+	 /* Allocate chrdev region */
+	 drv_cdev->count = DEFAULT_CDEV_COUNT;
+	 if(dev_major) {
+		 drv_cdev->cdev_num = MKDEV(dev_major, baseminor);
+		 ret = register_chrdev_region(drv_cdev->cdev_num, DEFAULT_CDEV_COUNT,
+			 (const char*)DEFAULT_DEVICE_NAME);
+	 } else {
+		 /* This is the first device. */
+		 ret = alloc_chrdev_region(&(drv_cdev->cdev_num), baseminor,
+			  DEFAULT_CDEV_COUNT, (const char*)DEFAULT_DEVICE_NAME);
+		 dev_major = MAJOR(drv_cdev->cdev_num);
+	 }
+ 
+	 if(ret)
+		 goto fail;
+ 
+	 /* If first device, create class. */
+	 strncpy(drv_cdev->drv_cls_str, (const char*)DEFAULT_CLS_NAME, CLS_STR_SIZE);
+ 
+	 if(!drv_cdev->dev_class) {
+		 cls_created = true;
+		 drv_cdev->dev_class = class_create(THIS_MODULE, drv_cdev->drv_cls_str);
+		 if (IS_ERR(drv_cdev->dev_class)) {
+			 ret = PTR_ERR(drv_cdev->dev_class);
+			 PR_ERR("Failed to create class %s. ret : %d",
+				 drv_cdev->drv_cls_str, ret);
+			 goto unreg_cdev_reg;
+		 }
+		 drv_cdev->dev_class->devnode = devnode;
+	 }
+ 
+	 /* Create device */
+	 snprintf(drv_cdev->dev_name, DEV_NAME_SIZE, "%s%d", DEFAULT_DEVICE_NAME, baseminor);
+	 drv_cdev->device = device_create(drv_cdev->dev_class, NULL,
+		 drv_cdev->cdev_num, NULL, drv_cdev->dev_name);
+	 if (IS_ERR(drv_cdev->device)) {
+		 ret = PTR_ERR(drv_cdev->device);
+		 PR_ERR("Failed to create device %s. ret : %d", drv_cdev->dev_name, ret);
+		 goto del_class;
+	 }
+ 
+	 /* Initialize the cdev structure */
+	 cdev_init(&(drv_cdev->cdev), fops);
+	 drv_cdev->cdev.owner = THIS_MODULE;
+	 drv_cdev->cdev.ops = fops;
+ 
+	 /*
+	  * Setting the parent is necessary so that the kobject is referenced
+	  * appropriately and the parent is not freed before the cdev.
+	  */
+	 if (parent)
+		 cdev_set_parent(&drv_cdev->cdev, &parent->kobj);
+	 
+	 /* Register cdev to the kernel */
+	 ret = cdev_add(&(drv_cdev->cdev), drv_cdev->cdev_num, drv_cdev->count);
+	 if (ret) {
+		 PR_ERR("Failed to register cdev to the kernel, err_code : %d", ret);
+		 goto del_device;
+	 }
+ 
+	 return SUCCESS;
+ 
+ del_device:
+	 device_destroy(drv_cdev->dev_class, drv_cdev->cdev_num);
+ 
+ del_class:
+	 if(cls_created)
+		 class_destroy(drv_cdev->dev_class);
+ 
+ unreg_cdev_reg:
+	 unregister_chrdev_region(drv_cdev->cdev_num, DEFAULT_CDEV_COUNT);
+ 
+ fail:
+	 return ret;
+ }
+ 
\ No newline at end of file
diff --git a/sw/AMI/driver/ami_cdev.h b/sw/AMI/driver/ami_cdev.h
index d58e3e6..39a9b8b 100755
--- a/sw/AMI/driver/ami_cdev.h
+++ b/sw/AMI/driver/ami_cdev.h
@@ -43,6 +43,7 @@
  * @cap_override: Bypass permission checks. This may not apply to all IOCTL's.
  * @efd: File descriptor for event notifications (used for progress reporting when
  *     performing long running operations like PDI downloads) - optional
+ * @partial: Flag to indicate whether the PDI is partial or full.
  *
  * Note that addr can be an address to any arbitrary data type,
  * depending on the context. This struct is reused for the boot select
@@ -63,6 +64,7 @@ struct ami_ioc_data_payload {
 	uint32_t       dest_part;
 	bool           cap_override;
 	int            efd;
+	bool           partial;
 };
 
 /**
diff --git a/sw/AMI/driver/ami_program.c b/sw/AMI/driver/ami_program.c
index cd0bafc..2951de8 100644
--- a/sw/AMI/driver/ami_program.c
+++ b/sw/AMI/driver/ami_program.c
@@ -29,6 +29,7 @@
  * @boot_device: Target boot device.
  * @partition: Partition number to flash.
  * @efd_ctx: eventfd context for reporting progress (optional).
+ * @partial: Flag to indicate partial download.
  *
  * If `partition` is equal to `FPT_UPDATE_MAGIC` will update the FPT.
  *
@@ -71,7 +72,7 @@ static int do_image_download(struct amc_control_ctxt *amc_ctrl_ctxt, uint8_t *bu
 			bytes_to_write = (size - bytes_written);
 		else
 			bytes_to_write = (PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER);
-		
+
 		/*
 		 * Don't invalidate the boot tag if we're updating the FPT
 		 * or if there is only a single chunk.
@@ -153,23 +154,121 @@ static int do_image_download(struct amc_control_ctxt *amc_ctrl_ctxt, uint8_t *bu
 	return ret;
 }
 
+static int do_image_download_partial(struct amc_control_ctxt *amc_ctrl_ctxt, uint8_t *buf, uint32_t size,
+	uint8_t boot_device, uint32_t partition, struct eventfd_ctx *efd_ctx)
+{
+	int ret = SUCCESS;
+	uint16_t chunk = 0;
+	uint32_t bytes_written = 0;
+	uint32_t bytes_to_write = 0;
+	printk("Size: %d\n", size);
+	uint16_t num_chunks = (size + ((PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER) - 1)) /
+		(PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER);
+	printk("num_chunks = %d\n", num_chunks);
+	if (!size || !amc_ctrl_ctxt || !buf)
+		return -EINVAL;
+
+	AMI_VDBG(
+		amc_ctrl_ctxt,
+		"Attempting to download partial PDI with image size %d, num_chunks = %d", size, num_chunks
+	);
+
+	while (bytes_written < size) {
+
+		if ((PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER) > (size - bytes_written))
+			bytes_to_write = (size - bytes_written);
+		else
+			bytes_to_write = (PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER);
+
+		/*
+		* This will copy the bitstream buffer into shared memory and submit
+		* the GCQ command. Using `flags` to pass in partition and chunk numbers.
+		*/
+		ret = submit_gcq_command(amc_ctrl_ctxt, GCQ_SUBMIT_CMD_DOWNLOAD_PARTIAL_PDI,
+			MK_PDI_FLAGS(boot_device, partition, chunk, false),
+			&buf[bytes_written], bytes_to_write);
+
+		if (ret)
+			break;
+
+		if (efd_ctx)
+			eventfd_signal(efd_ctx, bytes_to_write);
+
+		AMI_VDBG(
+			amc_ctrl_ctxt,
+			"Done with chunk %d",
+			chunk
+		);
+		chunk++;
+		bytes_written += bytes_to_write;
+	}
+
+	chunk = 0;
+	bytes_written = 0;
+	bytes_to_write = 0;
+
+	while (bytes_written < size) {
+
+		if ((PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER) > (size - bytes_written))
+			bytes_to_write = (size - bytes_written);
+		else
+			bytes_to_write = (PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER);
+
+		/*
+		* This will copy the bitstream buffer into shared memory and submit
+		* the GCQ command. Using `flags` to pass in partition and chunk numbers.
+		*/
+		ret = submit_gcq_command(amc_ctrl_ctxt, GCQ_SUBMIT_CMD_DOWNLOAD_PARTIAL_PDI,
+			MK_PDI_FLAGS(boot_device, partition, chunk, (chunk == (num_chunks - 1))),
+			&buf[bytes_written], bytes_to_write);
+
+		if (ret)
+			break;
+
+		if (efd_ctx)
+			eventfd_signal(efd_ctx, bytes_to_write);
+
+		AMI_VDBG(
+			amc_ctrl_ctxt,
+			"Done with chunk %d",
+			chunk
+		);
+		chunk++;
+		bytes_written += bytes_to_write;
+	}
+
+	if (ret)
+		AMI_ERR(amc_ctrl_ctxt, "Failed to download partial PDI, ret code: %d", ret);
+
+	return ret;
+}
+
 /*
  * Download a PDI bitstream.
  */
 int download_pdi(struct amc_control_ctxt *amc_ctrl_ctxt, uint8_t *buf, uint32_t size,
-	uint8_t boot_device, uint32_t partition, struct eventfd_ctx *efd_ctx)
+	uint8_t boot_device, uint32_t partition, struct eventfd_ctx *efd_ctx, uint8_t partial)
 {
 	if (!amc_ctrl_ctxt || !size || !buf || (partition == FPT_UPDATE_MAGIC))
 		return -EINVAL;
-
-	return do_image_download(
-		amc_ctrl_ctxt,
-		buf,
-		size,
-		boot_device,
-		partition,
-		efd_ctx
-	);
+	if (!partial)
+		return do_image_download(
+			amc_ctrl_ctxt,
+			buf,
+			size,
+			boot_device,
+			partition,
+			efd_ctx
+		);
+	else
+		return do_image_download_partial(
+			amc_ctrl_ctxt,
+			buf,
+			size,
+			boot_device,
+			partition,
+			efd_ctx
+		);
 }
 
 /*
diff --git a/sw/AMI/driver/ami_program.h b/sw/AMI/driver/ami_program.h
index 87da637..4bec2d8 100644
--- a/sw/AMI/driver/ami_program.h
+++ b/sw/AMI/driver/ami_program.h
@@ -66,11 +66,12 @@
  * @boot_device: Target boot device.
  * @partition: Partition number to flash.
  * @efd_ctx: eventfd context for reporting progress (optional).
+ * @partial: Flag to indicate whether the PDI is partial or full.
  * 
  * Return: 0 or negative error code.
  */
 int download_pdi(struct amc_control_ctxt *amc_ctrl_ctxt, uint8_t *buf, uint32_t size,
-	uint8_t boot_device, uint32_t partition, struct eventfd_ctx *efd_ctx);
+	uint8_t boot_device, uint32_t partition, struct eventfd_ctx *efd_ctx, uint8_t partial);
 
 /**
  * update_fpt() - Download a PDI containing an FPT onto a device.
